---
title: "并发工具类小记"
date: 2020-02-15T22:40:50+08:00
keywords: []
description: ""
tags: [
    "java"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
---

# 1 Semaphore

Semaphore 的作用是限制获取锁的线程数量，常用的 synchronized、ReentrantLock 均只能让一个线程进入代码块，而 Semaphore 可以允许同时有指定数量的线程进入代码块。

下面是一组示例代码

```java
    public static void main(String[] args) throws InterruptedException {
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 4; i++) {
            // todo 这里的代码是可能出现 bug 的，如果说 semaphore.acquire(); 
            // 加锁失败抛出异常，然后进入了 finally，那么后续 semaphore 内部
            // 允许的线程数就变成了 4
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName());
                    // run something...
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    // 这样写是确保如果出现异常也要将其释放
                    semaphore.release();
                }
            }).start();
        }
    }
```

Semaphore 内部是使用 AQS 的共享锁来实现的

# 2 CountDownLatch

用于起到类似于起跑线似的功能，能让几个线程在一瞬间同时启动向下执行。

在我看过源码之后，其实他内部是触发一个线程启动，然后启动的线程再去触发下一个线程启动，这样一步一步的触发，所以并不能算是完全的同时，只是近似。

下面是一组示例代码

```java
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < 3; i++) {
            // 让三个线程同时启动去打印时间
            new Thread(() -> {
                try {
                    countDownLatch.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(System.nanoTime());
            }).start();
        }
        countDownLatch.countDown();
    }
```

# 3 CyclicBarrier

CyclicBarrier 就像是一个栅栏，可以指定每次过栅栏的线程数，达到指定等待的线程数便让其一次性过去，在放过线程之后，栅栏会恢复原样。

下面是一段示例代码

```java
    public static void main(String[] args) {
        // 设置让三个线程同时过栅栏
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        for (int i = 0; i < 4; i++) {
            // 开四个线程过去，这里实际运行的时候由于是 4 个线程
            // 只有三个线程会过去，剩下的一个线程会被被阻塞在 await 处
            // 等待再来两个线程才会放行
            new Thread(() -> {
                try {
                    // 在这里等待
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
            }).start();
        }
    }
```