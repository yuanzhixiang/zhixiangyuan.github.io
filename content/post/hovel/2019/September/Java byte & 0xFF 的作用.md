---
title: "Java Byte & 0xFF 的作用"
date: 2019-09-16T14:40:00+08:00
keywords: []
description: ""
tags: [
    "Java"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
---

Java 代码中，经常能够见到 `byte & 0xFF` 这串代码，这是由于 Java 在处理 byte 的时候，将 byte 当作有符号来处理，所以比如说我们要进行 `byte << 8`，如果 byte 的第一位为 0，那么在左移的时候就会补 0，如果 byte 的第一位为 1，那么在左移的时候就会补 1，而我们希望在左移的时候均补 0，那么就可以采用 `(byte & 0xFF) << 8` 的形式。

在我的理解当中，`byte & 0xFF` 是将 byte 转换成了一个正的 int 数，下面来打个比方：

```java
/*
 * 这里打个比方，假如说 byte = 0b1100_1100，在进行计算的时候，byte 与 0xFF 被转换成了 int 进行计算
 * byte 0b1111_1111 1111_1111 1111_1111 1100_1100
 * 0xFF 0b0000_0000 0000_0000 0000_0000 1111_1111
 * 所以计算结果就是 0b0000_0000 0000_0000 0000_0000 1100_1100
 *
 * 这上面的计算你可能会有点疑问，0xFF 的第一位不是 1 么，为什么计算的时候前面怎么补的是 0，
 * 其实，虽然我写的时候写的是 0xFF 一个二进制字节，但是实际上，他还是一个 int 正数，如果
 * 不信，可以试着答应 System.out.println(0xFF) 试试看，打印出来的是负数还是正数。
 */
```

