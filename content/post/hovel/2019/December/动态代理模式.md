---
title: "动态代理模式"
date: 2019-12-20T10:47:26+08:00
keywords: []
description: ""
tags: [
    "设计模式"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
---

Java 的动态代理模式依靠 java.lang.reflect.Proxy 类来实现，下面是一个例子

```java
/** 定义一个接口 */
public interface IUserDao {
    void save();
}

/** 实现一个实现类 */
public class UserDaoImpl implements IUserDao {
    @Override
    public void save() {
        System.out.println("保存数据");
    }
}

/** 动态代理类实现工厂 */
public class ProxyFactory {

    /** 维护一个目标对象 */
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    /** 为目标对象生成代理对象 */
    public Object getProxyInstance() {
        // 传入 classLoader、对象的接口和代理对象的方法调用即可
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),
                (proxy, method, args) -> {
                    System.out.println("开启事务");

                    // 执行目标对象方法
                    Object returnValue = method.invoke(target, args);

                    System.out.println("提交事务");
                    return returnValue;
                });
    }
}

/** 测试效果 */
public class Main {
    public static void main(String[] args) {
        IUserDao target = new UserDaoImpl();
        // 输出代理对象信息
        System.out.println(String.format("origin class: [%s]", target.getClass()));
        IUserDao proxy = new ProxyFactory<>(target).getProxyInstance();
        // 输出代理对象信息
        System.out.println(String.format("proxy class: [%s]", proxy.getClass()));
        // 执行代理方法
        proxy.save();
    }
}

输出：
// 可以看到代理之前的类和代理之后类已经不是一个类了
// 经过 Java 动态代理之后的类变成了 com.sun.proxy.$Proxy0
origin class: [class me.yuanzx.demo.proxy.jdk.UserDaoImpl]
proxy class: [class com.sun.proxy.$Proxy0]
开启事务
保存数据
提交事务
```