---
title: "TCP：连接的建立与断开"
date: 2019-07-12T21:22:03+08:00
keywords: []
description: ""
tags: [
    "网络协议"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
---

# 1 TCP 连接的建立

注：下述序号用 seq 表示

1. A 生成一个 TCP 数据包，包中 SYN = 1，seq = x，然后将包发给 B
   - 此报文不能携带数据
2. B 收到包之后，生成一个 SYN = 1，ACK = 1，seq = y，ack = x+1 包，然后将包发给 A
   - 此报文不能携带数据
3. A 收到包之后，再回一个包，包中 ACK = 1，seq = x+1，ack = y+1，然后将包发给 B
   - 此报文可以携带数据，但是如果不携带数据，同样要携带 seq

注：

1. 上述的 x，y 可以随机生成
2. 上述的包里面虽然带了 seq，但是数据部分是空的。
3. 客户端和服务端的序号是分开的，在后续传输数据的时候，分别使用各自的序号。

![TCP 连接的建立](/media/hovel/11.jpg)

## 1.1 为什么要建立连接

连接建立时会初始化第一个发送字节的初始化序列号，建立连接之后，发送的每一串二进制数据都要以初始序列号为远点进行编号，需要对方来确认每一个字节编号都已经成功接收。这即保证了逻辑上不产生丢包，同时又保证了包的顺序。同时在建立连接的时候还会初始化一些别的参数，比如窗口大小等。

## 1.4 为什么序号不能从 1 开始

如果 A 和 B 建立了连接，发送了三个包，序号为 2，3，4，其中 4 由于等到超时发了两次，简单交流之后结束连接，结束之后又重新建立了连接，又从 1 开始，发了两个包 2，3，结果之前 4 那个包因为网络延迟问题，又到了，B 以为这是一个跟在 3 后面的包，就收进来了，这时候数据就错了，所以序号不能从 1 开始。

# 2 TCP 连接的断开

1. A 创建 TCP 数据包，FIN=1，seq=p，然后发送给 B，进入 FIN-WAIT-1 状态
2. B 回复 TCP 数据包，ACK=1，ack=p+1，然后发送给 A，进入 CLOSE-WAIT 状态
3. A 收到 B 的 ACK 包，就进入 FIN-WAIT-2 状态
4. B 再次向 A 发送 FIN=1，ACK=1，seq=q，ack=p+1，然后进入 LAST-ACK 状态
5. 当 A 收到 B 数据包，A 会回复 B 一个数据包 ACK=1，ack=q+1，然后进入 TIME-WAIT 状态，并且等待 2MSL 的时间
6. B 如果一段时间没有收到 ACK，则会再次发送 FIN 包

![TCP 连接的断开](/media/hovel/12.jpg)

在 A 进入 FIN-WAIT-2 状态之后，如果 B 直接跑路了，那么 A 会永远处于这个状态，TCP 协议里面没有明确对于这个状态的处理，不过 Linux 有，Linux 中有一个 tcp_fin_timeout 参数，这是一个超时时间，A 会在这个状态等待直到越过超时时间。