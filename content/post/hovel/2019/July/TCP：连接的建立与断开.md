---
title: "TCP：连接的建立与断开"
date: 2019-07-12T21:22:03+08:00
keywords: []
description: ""
tags: [
    "网络协议"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
---

# 1 TCP 连接的建立

注：下述序号用 seq 表示

1. A 生成一个 TCP 数据包，包中 SYN = 1，seq = x，然后将包发给 B
   - 此报文不能携带数据
2. B 收到包之后，生成一个 SYN = 1，ACK = 1，seq = y，ack = x+1 包，然后将包发给 A
   - 此报文不能携带数据
3. A 收到包之后，再回一个包，包中 ACK = 1，seq = x+1，ack = y+1，然后将包发给 B
   - 此报文可以携带数据，但是如果不携带数据，同样要携带 seq

注：

1. 上述的 x，y 可以随机生成
2. 上述的包里面虽然带了 seq，但是数据部分是空的。
3. 客户端和服务端的序号是分开的，在后续传输数据的时候，分别使用各自的序号。

![TCP 连接的建立](/media/hovel/11.jpg)

## 1.1 为什么要建立连接

连接建立时会初始化第一个发送字节的初始化序列号，建立连接之后，发送的每一串二进制数据都要以初始序列号为远点进行编号，需要对方来确认每一个字节编号都已经成功接收。这即保证了逻辑上不产生丢包，同时又保证了包的顺序。

## 1.2 为什么不是两次握手

假设有 A，B 两个端，A 向 B 发送 TCP 连接请求，A 发了第一个请求之后，一直没等来 B 的 ACK 包，A 以为第一个包丢了，就发了第二个连接请求，第二个连接请求顺利到达 B 端，建立起了连接，然后 A，B 进行了简单通讯后断开了连接，这个时候 A 发的第一个请求由于网络延迟的原因到达了 B，B 以为是一个正常请求，就和 A 建立了连接，但其实这个连接已经是一个过期的连接了，B 也等不来 A 的数据和断开连接的请求，这就浪费了资源。

但是如果是三次握手就不一样，当 B 收到这样一个连接的时候，B 会返回一个 ACK 给 A，如果 A 不再次给 B 来一个 ACK，那么连接就不会建立，而当 A 收到这个 B 的这个过期的 ACK 的时候，发现对不上，就不会再发 ACK 给 B，连接也就不会建立起来。

## 1.3 为什么不是四次握手

三次握手解决了连接重复建立的问题，如果第三次 A 发给 B 的 ACK 包丢了，B 在等待超时之后也会重新发送第二次的握手包，整个过程直到成功为止，所以没有必要进行四次握手。

## 1.4 为什么序号不能从 1 开始

如果 A 和 B 建立了连接，发送了三个包，序号为 2，3，4，其中 4 由于等到超时发了两次，简单交流之后结束连接，结束之后又重新建立了连接，又从 1 开始，发了两个包 2，3，结果之前 4 那个包因为网络延迟问题，又到了，B 以为这是一个跟在 3 后面的包，就收进来了，这时候数据就错了，所以序号不能从 1 开始。

# 2 TCP 连接的断开

1. A 创建 TCP 数据包，FIN=1，seq=p，然后发送给 B，进入 FIN-WAIT-1 状态
2. B 回复 TCP 数据包，ACK=1，ack=p+1，然后发送给 A，进入 CLOSE-WAIT 状态
3. A 收到 B 的 ACK 包，就进入 FIN-WAIT-2 状态
4. B 再次向 A 发送 FIN=1，ACK=1，seq=q，ack=p+1，然后进入 LAST-ACK 状态
5. 当 A 收到 B 数据包，A 会回复 B 一个数据包 ACK=1，ack=q+1，然后进入 TIME-WAIT 状态，并且等待 2MSL 的时间
6. B 如果一段时间没有收到 ACK，则会再次发送 FIN 包

![TCP 连接的断开](/media/hovel/12.jpg)

在 A 进入 FIN-WAIT-2 状态之后，如果 B 直接跑路了，那么 A 会永远处于这个状态，TCP 协议里面没有明确对于这个状态的处理，不过 Linux 有，Linux 中有一个 tcp_fin_timeout 参数，这是一个超时时间，A 会在这个状态等待直到越过超时时间。