---
title: "线程池解析"
date: 2019-08-05T17:26:17+08:00
keywords: []
description: ""
tags: [
    "Java 基础"
]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
draft: true
---

# ThreadPoolExecutor 的构造函数

```java
    public ThreadPoolExecutor(
            // 核心线程数，默认不会被回收掉，但是如果设置了 allowCoreThreadTimeOut 
            // 为 ture，那么当核心线程闲置超时，也会被回收
            int corePoolSize,
            // 最大线程数，线程池能容纳的最大容量
            // 上限被 CAPACITY 限制 (2^29 - 1)
            int maximumPoolSize,
            // 闲置线程的存活时间
            long keepAliveTime,
            // keepAliveTime 的单位
            TimeUnit unit,
            // 用于存放任务的队列
            BlockingQueue<Runnable> workQueue,
            // 创建线程的工厂类
            ThreadFactory threadFactory,
            // 任务失败时的执行策略，Java 自带了四个策略
            // 如果需要自定义也可以自己实现
            RejectedExecutionHandler handler
    ) {
        if (corePoolSize < 0 ||
                maximumPoolSize <= 0 ||
                maximumPoolSize < corePoolSize ||
                keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

# public void execute(Runnable command)

execute 方法便是将需要执行的任务加入到线程池当中，但是这个方法无法获取线程执行的结果。

```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
         // 取出线程池中的 ctl
        int c = ctl.get();
        // 取出 ctl 中的工作线程数，并且和 corePoolSize 做比较
        if (workerCountOf(c) < corePoolSize) {
            // 如果工作线程数小于 corePoolSize 则执行 addWorker 方法
            // 创建新的线程执行任务
            if (addWorker(command, true))
                // 添加任务成功则直接返回
                return;
            // 添加失败则再次取出 ctl
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

# private static int workerCountOf(int c)

```java
    private static int workerCountOf(int c)  {
        // 从 c 中取出后 29 位的数字
        // c         0bxxxxxxxx_xxxxxxxx_xxxxxxxx_xxxxxxxx
        // CAPACITY  0b00011111_11111111_11111111_11111111
        // CAPACITY 就像筛子一样，将 c 的后 29 位全部筛出来了
        return c & CAPACITY;
    }
```

# private boolean addWorker(Runnable firstTask, boolean core)

# 