---
title: "趣谈网络协议：第一模块 通信协议综述（4 讲）"
date: 2019-07-06T23:01:46+08:00
keywords: []
description: ""
tags: [
    "极客时间"
]
categories: [
    "天凉好个秋"
]
autoCollapseToc: true
author: "yuanzx"
draft: true
---

## 第 1 讲 | 为什么要学网络协议？

ps：老实说，第一次看到 Hello world！打印出来的时候，内心毫无波动，甚至有点无聊，就这，能有啥用。。。

### 协议三要素

1. 语法：就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。
2. 语义：就是这一段内容代表某种意义。例如，数字减去数字是有意义的，数字减去文本一般来说就没有意义。
3. 顺序：就是先干啥，后干啥。例如，可以先加上某个数值，再减去某个数值。

### 一次 HTTP 请求会发生什么

1. 浏览器打开 [https://www.kaola.com](https://www.kaola.com) 
2. 浏览器根据 DNS 查找到域名对应的 IP 地址
3. 将请求包装成 HTTP 请求传给传输层
4. 选择 TCP 进行包装，然后将消息传给网络层
5. 网络层判断 IP 是本地还是外地，是外地则将数据包交给 MAC 层
6. MAC 层通过网卡将数据包发给网关
7. 网关收到包之后根据路由表（网关往往是一个路由器，那它还可能不是一个路由器？）
8. 路由一次次跳转最终到达目的地，到达之后会有一个 response 的包告诉客户端收到了

### 我们常用的网络协议有哪些？

1. 应用层协议：DHCP，HTTP，HTTPS，RTMP，P2P，DNS，GTP，RPC
2. 传输层：TCP，UDP
3. 网络层：ICMP，IP，OSPF，BGP，IPSec，GRE
4. 链路层：ARP
5. 物理层：网络跳线

### 有了 MAC 地址为什么还需要 IP 地址？

IP 地址本质上是终点地址，它在跳过路由器的时候不会改变，而 MAC 地址则是下一跳的地址，没跳过一次路由器都会改变。

同时，如果只知道 MAC 地址，那么是没有办法定位需要访问哪里的，IP 便起到了定位的作用。

## 第 2 讲 | 网络分层的真实含义是什么？

### 网络为什么要分层？

复杂的程序都要分层，这是程序设计的要求，每个层干每个层负责的事。

### 程序是如何工作的？

![图解过程](/media/book_abstract/5.jpg)

1. 发起 HTTP 请求 send_tcp(buffer)
2. 将 HTTP 请求的前面增加 TCP 头，头里面包含源端口号，然后调用 send_layer3(buffer)
3. send_layer3 在包的前面加一个 IP 的头，头中包含源 IP 地址和目标 IP 地址，然后调用 send_layer2(buffer)
4. send_layer2 在包的前面加一个 MAC 的头，头中包含本机器的 MAC 地址和目标的 MAC 地址
   - 目标的 MAC 地址如果知道则直接加上，如果不知道，就要通过一定的协议处理过程，找到 MAC 地址。反正要填一个，不能空着。
5. 所有步骤走完，则将数据包发送出去
6. 有的网络配置成混杂模式，凡是经过的数据包都拿进来
7. 进来后调用 process_layer2(buffer)，摘下二层头（MAC 地址）
   - MAC 地址和本机相符，则调用 process_layer3(buffer)
   - MAC 地址和本机不符，则将包转发走（这里应该还是要调用 process_layer3(buffer) 摘下 IP，这样才能知道发到哪里）
8. process_layer3(buffer) 摘下三层头（IP 地址）
   - IP 地址是本机，则调用 process_tcp(buffer)
   - IP 地址不是本机，则将包转发走
9. process_tcp(buffer) 查看四层的头
   - 如果是一个发起、应答包，接下来可能要发送一个回复包
   - 如果是一个正常的数据包，就交给上层了，四层的头里面有端口号，根据端口号交给相应的应用程序

### 揭秘层与层之间的关系

1. 所有不能表示出层层封装含义的比喻，都是不恰当的。
2. 只要是在网络上跑的包，都是完整的，可以有下层没上层，绝对不可能有上层没下层
3. 对于 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发送不出去的。

## 第 3 讲 | ifconfig ：熟悉又陌生的命令行

### 怎样查看 IP 地址

- windows：ipconfig
- linux：ifconfig or ip addr

### 使用 ip addr 查看 ip

```bash
root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:fec7:7975/64 scope link 
       valid_lft forever preferred_lft forever
```

- inet 后面的 10.100.122.2/24 便是 IP 地址
- brd 后面的 10.100.122.255 是广播地址
- scope 后面 global 说明这张网卡是可以对外的，可以接受来自各个地方的包，host 则说明这张网卡仅仅用于供本机互相通信。

lo 全称是 loopback，又称环回接口，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。

### MAC 地址

IP 地址的上一行 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff 便是 MAC 地址，这是一个网卡的物理地址，用十六进制，6 个 byte 表示。

IP 地址与 MAC 地址关系就像门牌号和手机号，快递员根据门牌号找到你所在的地方，然后打电话叫你过来取快递。

MAC 地址具有全网唯一性，这是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。

### 网络设备的状态标示

MAC 地址上面的 <BROADCAST,MULTICAST,UP,LOWER_UP> 叫做 net_device flags（网络设备的状态标识）

- BROADCAST 表示这个网卡有广播地址，可以发广播包
- MULTICAST 表示网卡可以发送多播包
- UP 表示网卡处于启动状态
- LOWER_UP 表示 L1 是启动的，也就是插着网线呢
- mtu 1500 表示最大传输单元 MTU 为 1500，这是以太网的默认值
  - MTU 是二层 MAC 层的概念，MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头，如果放不下，就需要分片来传输。
- qdisc pfifo_fast：qdisc 全称是 queueing discipline（排队规则），内核如果需要通过某个网络接口发送数据包，它都需要为这个接口配置 qdisc（排队规则）把数据包加入队列。
  - 最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。
  - 三个波段（band）的优先级也不相同，band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样
  - 数据包是按照服务类型（Type of Service，TOS）被分配到三个波段（band）里面的。TOS 是 IP 里面的一个字段，代表了当前的包是高优先级的还是低优先级的

### ifconfig 和 ip addr 的区别

这个和 net-tools 和 iproute2 的历史故事有关，// todo 待完成

### IP 地址的分类

![IP 地址分类图](/media/book_abstract/6.jpg)

下面这个表格详细展示了 A、B、C 三类地址所能包含的主机的数量

![A、B、C 三类地址所能包含的主机的数量](/media/book_abstract/7.jpg)

这里面有个很尴尬的事，就是 C 类地址能包含的最大主机数量是在太少，只有 254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧，而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。

### 无类型域间选路（CIDR）

无类型域间选路就是为了解决上述问题的，它打破了原来设计的几类地址的做法将32位的IP地址一分为二，前面是网络号，后面是主机号。

10.100.122.2/24 便是一个这种类型的 IP，这个IP地址中有一个斜杠，斜杠后面有个数字 24，后面 24 的意思是，32 位中，前 24 位是网络号，后8位是主机号。

- 广播地址：10.100.122.255，如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到
- 子网掩码：255.255.255.0，将子网掩码和IP地址按位计算AND，就可得到网络号
    - 将子网掩码和 IP 地址进行 AND 计算。前面三个 255，转成二进制都是 1。1 和任何数值取 AND，都是原来数值，因而前三个数不变，为 10.100.122。后面一个 0，转换成二进制是 0，0 和任何数值取 AND，都是 0，因而最后一个数变为 0，合起来就是 10.100.122.0，这就是网络号。

### 私有 IP 地址和公有 IP 地址

表格最右列是私有 IP 地址段，因为这些地址允许组织内部 IT 人员自己管理、自己分配，所以可以重复。

![私有 IP 地址段](/media/book_abstract/8.jpg)

表格中的 192.168.0.x 是一个最常用的私有 IP 地址，你家里有 WIFI，对应就会有 IP 地址，一般你家里的上网设备不会超过 256 个，所有 /24 基本就够用了，有时候我们也能见到 /16 的 CIDR，这两种是最常见的，也最容易理解。其中 192.168.0 是网络号，后面是主机号，整个网络里面的第一个地址是 192.168.0.1，往往这就是这个私有网络的出口地址，家里的路由器就是这个地址，192.168.0.255 就是广播地址，一旦发送这个地址，整个 192.168.0 网络里面的所有机器都能收到。

公有 IP 地址有个组织统一分配，你需要去购买。

### 举例：一个容易“犯错”的 CIDR

我们来看16.158.165.91/22这个CIDR。求一下这个网络的第一个地址、子网掩码和广播地址。

你要是上来就写16.158.165.1，那就大错特错了。

/22 不是 8 的整数倍，不好办，只能先变成二进制来看。16.158 的部分不会动，它占了前 16 位。中间的 165，变为二进制为 ‭10100101‬。除了前面的 16 位，还剩 6 位。所以，这 8 位中前 6 位是网络号，16.158.<101001>，而 <01>.91 是机器号。

第一个地址是 16.158.<101001><00>.1，即 16.158.164.1。子网掩码是 255.255.<111111><00>.0，即255.255.252.0。广播地址为 16.158.<101001><11>.255，即 16.158.167.255。

- 第一个地址：16.158.164.1
- 子网掩码：255.255.252.0
- 广播地址：16.158.167.255

### IP 地址是怎样来的 

// todo 待完成

## 第 4 讲 | DHCP 与 PXE ：IP 是怎么来的，又是怎么没的？

### 如何配置 IP 地址

使用 net-tools：
```shell
$>sudo ifconfig eth1 10.0.0.1/24
$>sudo ifconfig eth1 up
```

使用 iproute2：
```shell
$>sudo ip addr add 10.0.0.1/24 dev eth1
$>sudo ip link set up eth1
```

真正配置的时候，一定不是直接用命令配置，而是放在一个配置文件里面。不同系统的配置文件格式不同，但是无非就是 **CIDR**、**子网掩码**、**广播地址**、和**网关地址**。

### IP 地址能随便设置么

不能，假如将 IP 地址设置为 16.158.23.6，然后你想把数据发送到 192.168.1.6，哪怕你们连接在一个交换机上，也是发不出去的。原因如下：

1. 现在知道源 IP 、目标 IP 和自己的 MAC 地址，但是目标的 MAC 地址不知道
2. Linux 会去判断这两个地址是同一个网段么
   - 如果是，则会发送 ARP 请求获取 MAC 地址
   - 如果不是，那么它会企图将包发到网关（这里不太理解，那如果配好一个网关，然后网关收包发到目标地址不就行了）

### 动态主机配置协议（DHCP）

DHCP（Dynamic Host Configuration Protocol）

网络管理员只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后会自动配置好，等用完了，自动还回去，这样其他机器也能用。

### 解析 DHCP 的工作方式

#### DHCP Discover

当一台新机器加入网络的时候，它会大吼一声，也就是 DHCP Discover 这个过程。发送一个广播包，源 IP 地址为 0.0.0.0，目的 IP 地址为 255.255.255.255，广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的花，很可能看到的还是 BOOTP 协议。

DHCP Discover 的格式如下：

![数据包格式](/media/book_abstract/9.jpg)

#### DHCP Offer

如果这个网络里面配置了 DHCP Server 的话，Server 收到这个请求，发现这个 MAC 地址是新的，那么就知道了这是一个新的机器，需要给他一个 IP 地址，这个过程就称为 DHCP Offer，这个时候 Server 会锁定这个 IP，不再将其分配给别的机器，直到这个 IP 不再使用。

DHCP Server 仍然使用广播地址作为目的地址，因为新机器还没有自己的 IP，这条广播中还发送了子网掩码、网关和 IP 地址租用期等信息。

DHCP Offer 的格式如下：

![数据包格式](/media/book_abstract/10.jpg)

#### DHCP Request

当新机器收到 DHCP Offer 的数据包后，会回复一个 DHCP Request 的广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销他们提供的 IP 地址，以便提供给下一个 IP 租用请求者。如果新机器收到多个 DHCP Offer 数据包，一般会采用收到的第一个 DHCP Offer 数据包。

DHCP Request 的格式如下：

![数据包格式](/media/book_abstract/11.jpg)

#### DHCP ACK

当 DHCP Server 接收到客户机的 DHCP Request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放到该广播包，发送给客户机，欢迎它加入网络大家庭。

DHCP ACK 的格式如下：

![数据包格式](/media/book_abstract/12.jpg)

#### IP 地址的收回和续租

IP 地址是租来的，那么就有收回的一天，如果要续租的话，需要提前一段时间和 DHCP Server 说，客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP Request 消息包，客户机收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数更新自己的配置，这样续租就完成了。

#### 预启动执行环境（PXE）

PXE：Pre-boot Execution Environment

PXE 能够帮着安装操作系统，这个需求出现在数据中心里面，当管理员一次拿到几百台机器的时候，如果是手动去安装系统，怕是累到辞职，所以这个时候，自动安装系统就很关键了。

这个过程和操作系统启动的过程有点像，首先启动 BIOS，这是一个特别小的小系统，只能干一件事，就是读取硬盘 MBR 启动扇区，将 GRUB 启动起来，然后将权力交给 GRUB，GRUB加载内核、加载作为根文件系统的 initramfs 文件，然后将全力交给内核，最后内核启动，初始化整个操作系统。

PXE 的流程是，BIOS 启动将 PXE 客户端调入内存里面，就可以连到服务器做一些操作了，首先 PXE 客户端自己也需要有个 IP 地址，因为 PXE 客户端启动起来，就可以发一个 DHCP 请求，获取到一个 IP 地址，PXE 客户端不仅在这个 DHCP 中获取到了 IP 地址，同时获取到了 PXE 的服务器地址，以及需要下载的文件的文件名，那么他就会去 PXE 服务器上下载那个文件，然后去初始化操作系统。

以下是 DHCP Server 的配置：

```
ddns-update-style interim;
ignore client-updates;
allow booting;
allow bootp;
subnet 192.168.1.0 netmask 255.255.255.0
{
    option routers 192.168.1.1;
    option subnet-mask 255.255.255.0;
    option time-offset -18000;
    default-lease-time 21600;
    max-lease-time 43200;
    range dynamic-bootp 192.168.1.240 192.168.1.250;
    filename "pxelinux.0";
    next-server 192.168.1.180;
}
```
DHCP Server 中配置了 IP 地址段、子网掩码、网关地址、租期等。如果想使用 PXE，则需要配置 next-server，指向 PXE 服务器的地址，另外要配置初始启动文件的 filename。

#### 解析 PXE 的工作过程

1. 启动 PXE 客户端
2. 通过 DHCP 协议从 DHCP Server 获取 IP 地址、PXE 服务器地址、启动文件名称 pcelinux.0
3. PXE 客户端去 PXE 服务器下载这个文件，下载协议使用的是 TFTP 协议，所以 PXE 服务器上往往还需要一个 TFTP 服务器
4. PXE 客户端收到这个文件后，就开始执行这个文件。这个文件会指示 PXE 客户端，向 TFTP 服务器请求计算机的配置信息 pxelinux.cfg。TFTP 服务器会给 PXE 客户端一个配置文件，里面会说内核在哪里、initramfs 在哪里。PXE 客户端会请求这些文件。
5. 最后启动 Linux 内核，一旦启动操作系统，以后啥都好办了。

![PXE 工作流程图](/media/book_abstract/13.jpg)

#### 如何使用 PXE 协议一次安装操作系统，后面正常启动

// todo 待完成

# 参考资料

1. [趣谈网络协议](https://time.geekbang.org/column/intro/85)