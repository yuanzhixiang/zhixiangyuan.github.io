---
title: "阿里巴巴中间件招聘"
date: 2020-08-16T20:21:00+08:00
keywords: []
description: ""
tags: [

]
categories: [
    "杂货铺"
]
autoCollapseToc: false
author: "yuanzx"
draft: true
---

# 你们系统中用到了分布式锁，能说一下这一块的用法么

由于这是一个分布式的系统，设计的时候是为每一台设备配备一个全系统唯一的数据处理器去处理设备传输过来的数据。所以在开启数据处理器的时候需要判断当前是否有正在运行的数据处理器，这一步的判断用到了分布式锁。

主流分布式锁的实现方式有三种，分别是基于数据库、基于缓存和基于 zookeeper 的实现方式，在系统中选择使用缓存的方式来实现分布式锁，主要是因为系统中已经引入了 redis 作为缓存，并且 redis 是使用阿里提供的服务来保证高可用。没有使用 zookeeper 是因为使用数据库实现的分布式锁性能和 zookeeper 差不多，而系统中本身没有使用 zookeeper，如果增加 zookeeper 还需要考虑 zookeeper 的维护问题所以没有采用 zookeeper 来作为临时方案，而使用数据库来实现没有缓存的效率高。

这里使用 redis 实现分布式锁，在每次受到开启数据处理器的通知后去开启数据处理器，通过 setex 命令设置一个 key-value 键值并加上过期时间，设置的 key 是设备的标识，value 是处理器的唯一标识，这个标识是在启动设备处理器时生成的 UUID，在处理器处理数据之前获取 redis 中存储的处理器的 UUID，然后和内存中缓存的 UUID 做比较，如果不是内存中缓存的 UUID 则说明当前的设备处理器不是最新的，则将当前处理器结束掉。如果是当前的处理器那么则重新设置过期时间。

# 为什么不能是多处理器去处理数据呢

由于传输过来的数据是连续的心电波形数据，数据需要保持它的连续性，对于单处理器的情况，处理器在处理好之后将数据发送到 MQTT 的代理上面，然后由消费者进行消费，整个流程可以很好的维持数据的连续性，如果改成多处理器处理的情况，那么可能会出现某些时间较晚的数据较早处理好并发送到 MQTT，那么数据的连续性就乱掉了，消费端在消费的时候便会出现问题。如果专门为了解决这个连续性的问题去实现一个服务做处理，会增大系统的复杂度和维护难度。而单处理器在使用性能上也没有问题，所以没有必要改成使用多处理器的情况。

# 如果说 redis 哪怕有高可用，但是挂了那系统怎么办

首先系统保证了 redis 是高可用的，但是如果 redis 挂了，接收器在接收到数据后无法将数据放入 redis 队列，那么便会将数据暂时缓存到本地系统文件中，等 redis 恢复正常再从本地文件中读取数据写入到 redis 中，确保数据不会丢失。

# 既然你说你们系统里面用到了 Netty，你能介绍一下对于 Netty 的了解么

Netty 是一个网络通信框架，他诞生于 Java 1.4 的版本，之所以引入了 Nio 机制，之所以引入 Nio 是由于之前的 io 模型是一个主循环去做 accept 操作，如果有新连接，那么则从线程池里面取出一个线程去处理连接，这就造成了连接数的上限取决于线程数，而线程是一个很宝贵的资源，这就严重限制了 io 的性能，因此便引入了 nio，nio 的功能基于操作系统底层的 select、poll、epoll 的系统调用实现，好处是只使用了一个线程便实现了管理所有连接的效果。所有的链接是注册在一个 selector 上面的，selector 如果监控到某个连接有事件发生，比如说 accept、read 这样的事件，那么会通知相关的进程来进行处理。但是 JDK 本身提供出来的 api 编程模型非常的复杂，所以 Netty 的作者便对 jdk 的 Nio 做了封装，简化了其编程模型。框架出来之后在社区反映很好，所以 Netty 框架便一直更新至今。同时 Apacha 内部也实现了一个网络通信框架叫 Mina，并且也邀请了 Netty 的作者参与开发。Netty 和 Mina 的线程模型是相同的 reactor in threads，Main Reactor + Sub Reactors，Main Reactor 只负责处理建立连接的事件，在其建立连接之后将连接交给 Sub Reactor，之后连接读写的工作均是交给 Sub Reactor 来处理的。

// todo 这下面就要开始针对 Netty 介绍，或者是针对 Mina 与 Netty 的比较。