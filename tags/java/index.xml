<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Yuanzx Blog</title>
    <link>https://zhixiangyuan.github.io/tags/java/</link>
    <description>Recent content in Java on Yuanzx Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>yuanzx</copyright>
    <lastBuildDate>Thu, 12 Dec 2019 13:48:56 +0800</lastBuildDate>
    
	<atom:link href="https://zhixiangyuan.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JDK8 中新增的 TYPE_USE 和 TYPE_PARAMETER 可以用在什么场景</title>
      <link>https://zhixiangyuan.github.io/2019/12/12/jdk8-%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84-type_use-%E5%92%8C-type_parameter-%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 12 Dec 2019 13:48:56 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/12/jdk8-%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84-type_use-%E5%92%8C-type_parameter-%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF/</guid>
      <description>本篇直接用示例代码展示该注解可以用在什么场景 1 TYPE_USE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 先定义一个测试注解</description>
    </item>
    
    <item>
      <title>Java 的可重入锁可以重入多少次</title>
      <link>https://zhixiangyuan.github.io/2019/12/10/java-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%85%A5%E5%A4%9A%E5%B0%91%E6%AC%A1/</link>
      <pubDate>Tue, 10 Dec 2019 15:01:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/10/java-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%85%A5%E5%A4%9A%E5%B0%91%E6%AC%A1/</guid>
      <description>Java 中有两个常用的可重入锁，一个是 synchronized，另一个是 ReentrantLock，我们先测试 ReentrantLock 的可重入次数 1 ReentrantLock 的可重入次数上限 1</description>
    </item>
    
    <item>
      <title>自旋锁 与 适应性自旋锁</title>
      <link>https://zhixiangyuan.github.io/2019/12/09/%E8%87%AA%E6%97%8B%E9%94%81-%E4%B8%8E-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81/</link>
      <pubDate>Mon, 09 Dec 2019 20:30:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/09/%E8%87%AA%E6%97%8B%E9%94%81-%E4%B8%8E-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81/</guid>
      <description>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比</description>
    </item>
    
    <item>
      <title>谈谈 CAS</title>
      <link>https://zhixiangyuan.github.io/2019/12/09/%E8%B0%88%E8%B0%88-cas/</link>
      <pubDate>Mon, 09 Dec 2019 15:04:35 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/09/%E8%B0%88%E8%B0%88-cas/</guid>
      <description>CAS 其实指的就是 sun.misc.Unsafe 类中的一系列 compareAndSwap 方法 例如 compareAndSwapInt 方法 1 2 3 public final native boolean compareAndSwapInt( Object o, long offset, int expected, int x ); 这种方法提供四个参数，分别是需要修改值的对象 o，需要改的值在对</description>
    </item>
    
    <item>
      <title>乐观锁 与 悲观锁</title>
      <link>https://zhixiangyuan.github.io/2019/12/09/%E4%B9%90%E8%A7%82%E9%94%81-%E4%B8%8E-%E6%82%B2%E8%A7%82%E9%94%81/</link>
      <pubDate>Mon, 09 Dec 2019 14:25:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/09/%E4%B9%90%E8%A7%82%E9%94%81-%E4%B8%8E-%E6%82%B2%E8%A7%82%E9%94%81/</guid>
      <description>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度，在 Java 和数据库中都有此概念对应的实际应用。 1 概念 悲观锁的概念：悲观锁认为自己在</description>
    </item>
    
    <item>
      <title>深度跟踪 Class 的 public InputStream getResourceAsStream(String name) 方法</title>
      <link>https://zhixiangyuan.github.io/2019/12/07/%E6%B7%B1%E5%BA%A6%E8%B7%9F%E8%B8%AA-class-%E7%9A%84-public-inputstream-getresourceasstreamstring-name-%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 07 Dec 2019 06:31:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/07/%E6%B7%B1%E5%BA%A6%E8%B7%9F%E8%B8%AA-class-%E7%9A%84-public-inputstream-getresourceasstreamstring-name-%E6%96%B9%E6%B3%95/</guid>
      <description>本日志基于 openjdk8 1 public final class Class 我们从这个方法开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public InputStream getResourceAsStream(String name) { // 这个方法见 1.1 解析 // 这里假如传入的 name 为 /Web.xml</description>
    </item>
    
    <item>
      <title>大小写字母转换技巧</title>
      <link>https://zhixiangyuan.github.io/2019/12/05/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 05 Dec 2019 10:46:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/05/%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E8%BD%AC%E6%8D%A2%E6%8A%80%E5%B7%A7/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 小写转大写 * * @param c 小写字母 * @return 大写字母 */ public static char upper(char c) { return (char) (c &amp;amp; 0xdf); } /** * 大写转小写 * * @param</description>
    </item>
    
    <item>
      <title>FutureTask 的取消功能是怎么实现的</title>
      <link>https://zhixiangyuan.github.io/2019/12/03/futuretask-%E7%9A%84%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</link>
      <pubDate>Tue, 03 Dec 2019 20:19:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/03/futuretask-%E7%9A%84%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</guid>
      <description>本文基于 jdk 1.8 直接看取消的函数实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; { ... public boolean cancel(boolean mayInterruptIfRunning) { if (!(state == NEW &amp;amp;&amp;amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try {</description>
    </item>
    
    <item>
      <title>Java 中的 WeakReference 和 SoftReference</title>
      <link>https://zhixiangyuan.github.io/2019/11/28/java-%E4%B8%AD%E7%9A%84-weakreference-%E5%92%8C-softreference/</link>
      <pubDate>Thu, 28 Nov 2019 16:48:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/28/java-%E4%B8%AD%E7%9A%84-weakreference-%E5%92%8C-softreference/</guid>
      <description>1 WeakReference 当一个对象没有被强引用时，只有 WeakReference，那么在下一次 GC 时会被回收。 1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { Object referent = new Object(); WeakReference&amp;lt;Object&amp;gt; weakReference = new WeakReference&amp;lt;&amp;gt;(referent);</description>
    </item>
    
    <item>
      <title>ScheduledThreadPoolExecutor 的实现原理</title>
      <link>https://zhixiangyuan.github.io/2019/11/28/scheduledthreadpoolexecutor-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 28 Nov 2019 14:54:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/28/scheduledthreadpoolexecutor-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>1 如何实现定时的效果 定时效果实现的关键在 ScheduledFutureTask 的 public void run() 方法，下面是该方法的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void run() { // 判断是否是</description>
    </item>
    
    <item>
      <title>WeakReference 的使用场景</title>
      <link>https://zhixiangyuan.github.io/2019/11/26/weakreference-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Tue, 26 Nov 2019 11:33:07 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/26/weakreference-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>WeakReference 所指的便是弱引用，它的作用便是能够让你获取到引用到对象，但是当弱引用引用的对象没有强引用引用时，那么便可以被虚拟机回收。这个类可以用在下面</description>
    </item>
    
    <item>
      <title>如何在 Maven 打包的时候设置主类</title>
      <link>https://zhixiangyuan.github.io/2019/11/16/%E5%A6%82%E4%BD%95%E5%9C%A8-maven-%E6%89%93%E5%8C%85%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE%E4%B8%BB%E7%B1%BB/</link>
      <pubDate>Sat, 16 Nov 2019 22:02:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/16/%E5%A6%82%E4%BD%95%E5%9C%A8-maven-%E6%89%93%E5%8C%85%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE%E4%B8%BB%E7%B1%BB/</guid>
      <description>1 普通项目 在 maven 中配置以下插件即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; ... &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;addClasspath&amp;gt;true&amp;lt;/addClasspath&amp;gt; &amp;lt;classpathPrefix&amp;gt;lib/&amp;lt;/classpathPrefix&amp;gt; &amp;lt;mainClass&amp;gt;&amp;lt;$mainClass&amp;gt;&amp;lt;/mainClass&amp;gt; &amp;lt;/manifest&amp;gt; &amp;lt;/archive&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 原理便是在打包的时候，向 MANIFEST.MF 文件中</description>
    </item>
    
    <item>
      <title>javap 命令小记</title>
      <link>https://zhixiangyuan.github.io/2019/11/13/javap-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 13 Nov 2019 17:00:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/11/13/javap-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</guid>
      <description>通过 javap 命令可以反编译 .class 文件，实际使用的时候 javap 后面的类名加与不加 .class 都可以。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -help --help -? 打印使用信息（也就是打印图中所示</description>
    </item>
    
    <item>
      <title>Java 中的类加载器</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/java-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Sat, 26 Oct 2019 21:55:24 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/java-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description>Java 中的类加载器分为三种： 启动类加载器 扩展类加载器 应用程序类加载器 1 启动类加载器 Bootstrap ClassLoader，C 语言实现，用于加载 JDK\jre\lib\rt.jar 2 扩展类加载器</description>
    </item>
    
    <item>
      <title>类的加载过程</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 26 Oct 2019 21:54:10 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid>
      <description>类的加载分为以下五个步骤： 加载 连接 初始化 使用 卸载 1 加载 加载操作会去加载类的二进制数据到内存中，然后在堆中开辟出一个 java.lang.Class 对象 2 连接 连接又包含三个</description>
    </item>
    
    <item>
      <title>JVM 内存模型</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 26 Oct 2019 21:42:18 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>JVM 的内存模型分为主内存和线程的工作内存两大块，这属于一个抽象的内存模型，用于解决并发问题，与 JVM 中的内存结构如堆、栈没什么关系，不要弄混。 参考</description>
    </item>
    
    <item>
      <title>字符串常量池</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
      <pubDate>Sat, 26 Oct 2019 21:23:31 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
      <description>JVM 为了提高性能和减少内存开销，实现数据共享，所以引入了字符串常量池。字符串常量池存在于方法区当中，创建字符串常量时，首先判断字符串是否存在于</description>
    </item>
    
    <item>
      <title>JVM 堆内存中的结构</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 26 Oct 2019 20:43:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/jvm-%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84/</guid>
      <description>1 堆内存结构 堆内存中分为三块，分别是年轻代、老年代和方法区，Java 堆不需要连续的内存，可以动态增加内存，增加失败则抛出 OutOfMemoryError 异常 1.1 年轻代与老年</description>
    </item>
    
    <item>
      <title>常见的垃圾回收算法</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Oct 2019 20:34:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</guid>
      <description>1 标记清除算法 标记清除算法有两个阶段，标记阶段和回收阶段。标记阶段将需要被清除的对象打上标签，回收阶段完成对于对象的回收。这种算法回收过后会</description>
    </item>
    
    <item>
      <title>常见垃圾回收器</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</link>
      <pubDate>Sat, 26 Oct 2019 20:29:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</guid>
      <description>Serial Garbage Collector: 单线程 GC Parallel Garbage Collector: 多线程 GC CMS Garbage Collector: 多线程 GC G1 Garbage Collector: jdk7 引进的 GC 优点：多线程运行，适合高并发场景，暂停时间短 目标：逐步取代 CMS GC</description>
    </item>
    
    <item>
      <title>JVM 中如何判断对象生死</title>
      <link>https://zhixiangyuan.github.io/2019/10/26/jvm-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%AD%BB/</link>
      <pubDate>Sat, 26 Oct 2019 20:06:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/26/jvm-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%AD%BB/</guid>
      <description>1 引用器计数法 如果某个引用被别的引用引用一次，那么引用计数器就加一，引用计数器为 0 时便回收对象。 这种方法有缺陷，如果出现循环引用，那么 GC 便无</description>
    </item>
    
    <item>
      <title>Java 中的桥接方法</title>
      <link>https://zhixiangyuan.github.io/2019/10/23/java-%E4%B8%AD%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 23 Oct 2019 10:40:51 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/23/java-%E4%B8%AD%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95/</guid>
      <description>先看下面的接口与接口实现 1 2 3 4 5 6 7 8 9 10 public interface AInterface&amp;lt;T&amp;gt; { void func(T t); } public class AClass implements AInterface&amp;lt;String&amp;gt; { @Override public void func(String s) { System.out.println(s); } } 由于 Java 的泛型是要擦除的，所以当虚拟机看到的时候其实</description>
    </item>
    
    <item>
      <title>XPath 解析器示例</title>
      <link>https://zhixiangyuan.github.io/2019/10/22/xpath-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Tue, 22 Oct 2019 16:25:33 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/22/xpath-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%A4%BA%E4%BE%8B/</guid>
      <description>1 XPath 解析器示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63</description>
    </item>
    
    <item>
      <title>ThreadLocal 源码浅析</title>
      <link>https://zhixiangyuan.github.io/2019/10/18/threadlocal-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</link>
      <pubDate>Fri, 18 Oct 2019 16:36:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/18/threadlocal-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</guid>
      <description>ThreadLocal 用于不同线程存储不同的线程全局变量，在该线程下用 ThreadLocal 取出的值是一致的。这里先简述一下原理，然后再看代码。ThreadLocal 其实是一个 Ke</description>
    </item>
    
    <item>
      <title>Class 方法之 forName(String className) 小记</title>
      <link>https://zhixiangyuan.github.io/2019/10/04/class-%E6%96%B9%E6%B3%95%E4%B9%8B-fornamestring-classname-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Fri, 04 Oct 2019 20:29:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/10/04/class-%E6%96%B9%E6%B3%95%E4%B9%8B-fornamestring-classname-%E5%B0%8F%E8%AE%B0/</guid>
      <description>Class.forName(String className) 这个方法的作用就是触发类的初始化动作 1 2 public static Class&amp;lt;?&amp;gt; forName(String className) throws ClassNotFoundException 这个方法目前就仅在 JDBC 的初始化的时候见过，他的目的就是触发 JDBC 驱动注册到代码中，代码如</description>
    </item>
    
    <item>
      <title>Monitorenter 与 Monitorexit 小记</title>
      <link>https://zhixiangyuan.github.io/2019/09/23/monitorenter-%E4%B8%8E-monitorexit-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 23 Sep 2019 10:07:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/23/monitorenter-%E4%B8%8E-monitorexit-%E5%B0%8F%E8%AE%B0/</guid>
      <description>首先对如下代码进行编译 1 2 3 4 5 public void Test() { synchronized(this) { System.out.println(); } } 将得到的字节码通过 javap 反编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void</description>
    </item>
    
    <item>
      <title>ArrayList 使用注意事项</title>
      <link>https://zhixiangyuan.github.io/2019/09/18/arraylist-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 18 Sep 2019 18:24:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/18/arraylist-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>1 ArrayList 使用注意事项 如果一边对 ArrayList 中的元素做修改，一边使用 Iterator 对 ArrayList 进行遍历，则会抛出 ConcurrentModificationException 异常。 2 为什么会出现 ConcurrentModificationException 这个异常 通过翻看源码，能够找到下面这段代</description>
    </item>
    
    <item>
      <title>如何介绍一个集合类</title>
      <link>https://zhixiangyuan.github.io/2019/09/18/%E5%A6%82%E4%BD%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</link>
      <pubDate>Wed, 18 Sep 2019 16:02:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/18/%E5%A6%82%E4%BD%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</guid>
      <description>很多时候，作为一个程序员，仅仅会使用集合类是不够的，我们经常需要向别人介绍集合类，那么，在向别人介绍集合类的时候，我们应该从哪几个角度进行介</description>
    </item>
    
    <item>
      <title>Object 中 hashcode() 与 equals() 的关系</title>
      <link>https://zhixiangyuan.github.io/2019/09/17/object-%E4%B8%AD-hashcode-%E4%B8%8E-equals-%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Tue, 17 Sep 2019 17:14:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/17/object-%E4%B8%AD-hashcode-%E4%B8%8E-equals-%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>情况分为以下四种： hashcode 相等，equals 可能相等 hashcode 不相等，equals 一定不相等 equals 相等，hashcode 一定相等 equals 相等说明是同一个对象，所以 hashcode</description>
    </item>
    
    <item>
      <title>Java Byte &amp; 0xFF 的作用</title>
      <link>https://zhixiangyuan.github.io/2019/09/16/java-byte-0xff-%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Mon, 16 Sep 2019 14:40:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/16/java-byte-0xff-%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>Java 代码中，经常能够见到 byte &amp;amp; 0xFF 这串代码，这是由于 Java 在处理 byte 的时候，将 byte 当作有符号来处理，所以比如说我们要进行 byte &amp;lt;&amp;lt; 8，如果 byte 的第一位为 0，那么在</description>
    </item>
    
    <item>
      <title>Equals 方法的重写规则</title>
      <link>https://zhixiangyuan.github.io/2019/08/09/equals-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99/</link>
      <pubDate>Fri, 09 Aug 2019 09:24:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/09/equals-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99/</guid>
      <description>equals 方法有一些固定的规则，一些类（例如集合类）会按照规则使用 equals 方法，如果重写的时候不按照这些规则进行重写，那么在使用的时候就可能出现莫名其妙的</description>
    </item>
    
    <item>
      <title>ThreadPoolExecutor 解析</title>
      <link>https://zhixiangyuan.github.io/2019/08/06/threadpoolexecutor-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 06 Aug 2019 17:26:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/06/threadpoolexecutor-%E8%A7%A3%E6%9E%90/</guid>
      <description>1 ThreadPoolExecutor 的构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public ThreadPoolExecutor( // 核心线程数，默认不会被回收掉，但是如果设置了 allowCoreThreadTimeOut //</description>
    </item>
    
    <item>
      <title>数组的协变与范型的协变</title>
      <link>https://zhixiangyuan.github.io/2019/08/01/%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%8F%E5%8F%98%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98/</link>
      <pubDate>Thu, 01 Aug 2019 16:02:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/01/%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%8F%E5%8F%98%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98/</guid>
      <description>Java 中的数组是支持协变的，而范型不支持协变，先通过下面的代码了解什么是协变。 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { // Number 数组可以指向 Integer 数组 // 这就</description>
    </item>
    
    <item>
      <title>父类如何返回子类</title>
      <link>https://zhixiangyuan.github.io/2019/08/01/%E7%88%B6%E7%B1%BB%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E5%AD%90%E7%B1%BB/</link>
      <pubDate>Thu, 01 Aug 2019 14:59:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/08/01/%E7%88%B6%E7%B1%BB%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E5%AD%90%E7%B1%BB/</guid>
      <description>以 netty 的 AbstractBootstrap 为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 1. 父类中定义一个继承自己的范型 B. B extends AbstractBootstrap&amp;lt;B&amp;gt; public abstract class AbstractBootstrap&amp;lt;B extends AbstractBootstrap&amp;lt;B&amp;gt;&amp;gt;{ ... public B method1() { return self(); } public B method2() { return</description>
    </item>
    
    <item>
      <title>由无效缓存引起的内存泄漏</title>
      <link>https://zhixiangyuan.github.io/2019/07/30/%E7%94%B1%E6%97%A0%E6%95%88%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</link>
      <pubDate>Tue, 30 Jul 2019 20:36:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/30/%E7%94%B1%E6%97%A0%E6%95%88%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</guid>
      <description>在下面这段代码中存在一个内存泄漏的问题，在使用中表现为性能下降，在极端情况下甚至可能出现 OutOfMemoryError。先看代码，看你是否</description>
    </item>
    
    <item>
      <title>ReentrantLock 详解</title>
      <link>https://zhixiangyuan.github.io/2019/07/24/reentrantlock-%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 24 Jul 2019 21:31:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/24/reentrantlock-%E8%AF%A6%E8%A7%A3/</guid>
      <description>本文基于 JDK 1.8 1 ReentrantLock 的作用 Java 中已经有了 synchronized 的来进行隐式的加锁和解锁，那还为什么还要引入 ReentrantLock 这把锁呢。这主要是 synchronized 的加锁和解锁操作并不灵活，Reentr</description>
    </item>
    
    <item>
      <title>Unsafe 解析</title>
      <link>https://zhixiangyuan.github.io/2019/07/23/unsafe-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 23 Jul 2019 20:29:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/23/unsafe-%E8%A7%A3%E6%9E%90/</guid>
      <description>本文基于 jdk1.8 Unsafe 位于 sun.misc 包下，提供能直接访问系统内存资源的方法，使得用户能够自主管理内存，使用得当能够提升程序的运行效率。 1 如何获取 Unsafe 实例 下面代码</description>
    </item>
    
    <item>
      <title>Java 线程的生命周期</title>
      <link>https://zhixiangyuan.github.io/2019/07/21/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sun, 21 Jul 2019 20:09:56 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/21/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>Java 语言中的线程本质上就是操作系统的线程，Java 创建线程同样是调用操作系统的 API 来创建线程。所以，了解 Java 线程的生命周期的第一步是了解操作系统线</description>
    </item>
    
    <item>
      <title>通过银行转账问题解说死锁解决方案</title>
      <link>https://zhixiangyuan.github.io/2019/07/17/%E9%80%9A%E8%BF%87%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E9%97%AE%E9%A2%98%E8%A7%A3%E8%AF%B4%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 17 Jul 2019 09:26:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/17/%E9%80%9A%E8%BF%87%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E9%97%AE%E9%A2%98%E8%A7%A3%E8%AF%B4%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>1 如何解决银行转账时的并发问题 当出现 A 将钱转给 B 的时候，什么样的方案可以避免在转账时没有并发问题。先看以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description>
    </item>
    
    <item>
      <title>Java 解决可见性和有序性问题的方法</title>
      <link>https://zhixiangyuan.github.io/2019/07/16/java-%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 16 Jul 2019 17:24:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/16/java-%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>1 Happens-Before 规则 Java 通过提出 Happens-Before 规则来解决可见性和有序性的问题，Happens-Before 的意思是前面一个操作的结果对后续操作是可见的。 1.1 程序的顺序性</description>
    </item>
    
    <item>
      <title>并发编程需要解决的问题</title>
      <link>https://zhixiangyuan.github.io/2019/07/16/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 16 Jul 2019 10:08:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/16/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1 并发编程需要解决的问题 由于 CPU 从单核变成了多核引发了并发问题，其问题有三。一，每个 CPU 都有自己的缓存，当多个线程运行在不同核的 CPU 上并且修改同一</description>
    </item>
    
    <item>
      <title>double 转 BigDecimal 造成的精度丢失</title>
      <link>https://zhixiangyuan.github.io/2019/07/10/double-%E8%BD%AC-bigdecimal-%E9%80%A0%E6%88%90%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</link>
      <pubDate>Wed, 10 Jul 2019 16:07:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/10/double-%E8%BD%AC-bigdecimal-%E9%80%A0%E6%88%90%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</guid>
      <description>1 2 3 4 5 6 public static void main(String[] args) { double d1 = 36.8d; double d2 = 36.5d; BigDecimal subtract = new BigDecimal(d1).subtract(new BigDecimal(d2)); System.out.println(subtract); } 对于上述类型的计算会得到结果 0.29999999999999715782905695</description>
    </item>
    
    <item>
      <title>Java Gzip 的简单封装</title>
      <link>https://zhixiangyuan.github.io/2019/07/04/java-gzip-%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/</link>
      <pubDate>Thu, 04 Jul 2019 14:50:20 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/04/java-gzip-%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/</guid>
      <description>本文基于 Jdk 1.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.util.zip.GZIPInputStream; import java.util.zip.GZIPOutputStream; public class GzipUtil { /** *</description>
    </item>
    
    <item>
      <title>Java 性能优化</title>
      <link>https://zhixiangyuan.github.io/2019/07/02/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 02 Jul 2019 16:22:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/02/java-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>1 明确是否需要优化以及要优化到什么程度 首先需要在实践中检测代码是否需要优化，如果不需要优化，那么优化可能占用大量时间，而且优化完了也不会有任</description>
    </item>
    
    <item>
      <title>一次内存泄漏排查的经历</title>
      <link>https://zhixiangyuan.github.io/2019/07/01/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E7%9A%84%E7%BB%8F%E5%8E%86/</link>
      <pubDate>Mon, 01 Jul 2019 13:14:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/07/01/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E7%9A%84%E7%BB%8F%E5%8E%86/</guid>
      <description>开发环境: JDK: 1.8 Netty: 4.1.21.Final 1 起因 由于我之前写过一个接收医疗设备数据的项目，于是为了压力测试，就又按照该协议实现了一个发送设备数据的项目。这个项目在使</description>
    </item>
    
    <item>
      <title>Javap 命令的使用</title>
      <link>https://zhixiangyuan.github.io/2018/11/05/javap-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 05 Nov 2018 10:43:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/11/05/javap-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>通过 javap 命令可以反编译 .class 文件，实际使用的时候 javap 后面的类名加与不加 .class 都可以。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -help --help -? 打印使用信息（也就是打印图中所示</description>
    </item>
    
    <item>
      <title>final、finally、finalize 的异同</title>
      <link>https://zhixiangyuan.github.io/2018/10/17/finalfinallyfinalize-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Wed, 17 Oct 2018 16:40:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/10/17/finalfinallyfinalize-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>1 final final 可以用来修饰类、方法、变量 1.1 final 修饰类 final 修饰 class 代表类不可以被继承 1.2 final 修饰变量 final 修饰的变量在初始化之后不能被再次赋值 1.3 final 修饰方法 final 修饰方法</description>
    </item>
    
    <item>
      <title>Exception 与 Error 的异同</title>
      <link>https://zhixiangyuan.github.io/2018/10/16/exception-%E4%B8%8E-error-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Tue, 16 Oct 2018 11:26:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/10/16/exception-%E4%B8%8E-error-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有继承了 Throwable 的类才可以被 throw 或者 catch，它是异常处理机制的基本组成类型。Exception 是程序正常运行中，可</description>
    </item>
    
    <item>
      <title>HashMap 不得不说的故事</title>
      <link>https://zhixiangyuan.github.io/2018/09/03/hashmap-%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/</link>
      <pubDate>Mon, 03 Sep 2018 10:13:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/09/03/hashmap-%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/</guid>
      <description>本文基于 Jdk 1.8 1 什么是 HashMap 要理解这个问题，首先需要理解什么是 Hash 以及什么是 Map 1.1 什么是 Hash Hash 是一种散列算法，用于确定关键字到指定位置的对应关系 1.2 什么是</description>
    </item>
    
    <item>
      <title>int 入栈指令 iconst、bipush、sipush、ldc</title>
      <link>https://zhixiangyuan.github.io/2018/08/11/int-%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4-iconstbipushsipushldc/</link>
      <pubDate>Sat, 11 Aug 2018 18:47:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2018/08/11/int-%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4-iconstbipushsipushldc/</guid>
      <description>1 前言 本文介绍 int 数值入栈指令 iconst、bipush、sipubh、Idc。 根据 int 取值不同分为以下几种可能性： iconst: [-1, 5] bipush: [-128, -2]∪[6, 127] sipush:</description>
    </item>
    
  </channel>
</rss>