<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spring framework on Yuanzx Blog</title>
    <link>https://zhixiangyuan.github.io/tags/spring-framework/</link>
    <description>Recent content in spring framework on Yuanzx Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>yuanzx</copyright>
    <lastBuildDate>Mon, 13 Jan 2020 08:25:29 +0800</lastBuildDate>
    
	<atom:link href="https://zhixiangyuan.github.io/tags/spring-framework/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>为 Spring Bean 指定初始化和销毁方法的几种方式</title>
      <link>https://zhixiangyuan.github.io/2020/01/13/%E4%B8%BA-spring-bean-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 13 Jan 2020 08:25:29 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2020/01/13/%E4%B8%BA-spring-bean-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>1 Xml 方式指定 假设我们先创建下面这个 Bean 1 2 3 4 5 6 7 8 9 10 11 12 13 public class CoffeeBean { public CoffeeBean() { System.out.println(&amp;#34;Construct bean.&amp;#34;); } public void init() { System.out.println(&amp;#34;Bean init.&amp;#34;); } public void destroy() { System.out.println(&amp;#34;Bean destroy.&amp;#34;); } } 1 2 &amp;lt;bean id=&amp;#34;coffee&amp;#34; class=&amp;#34;me.yuanzx.test.CoffeeBean&amp;#34; init-method=&amp;#34;init&amp;#34; destroy-method=&amp;#34;destory&amp;#34;&amp;gt; &amp;lt;/bean&amp;gt; 2 在 @Bean 的时候</description>
    </item>
    
    <item>
      <title>Spring Aop 中 AspectJProxyFactory 的使用方式</title>
      <link>https://zhixiangyuan.github.io/2019/12/23/spring-aop-%E4%B8%AD-aspectjproxyfactory-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 23 Dec 2019 16:57:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/23/spring-aop-%E4%B8%AD-aspectjproxyfactory-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** 定义目标类 */ public class AspectTarget { public void method1() { System.out.println(&amp;#34;method1 execution&amp;#34;);</description>
    </item>
    
    <item>
      <title>Spring 中 BeanFactory 和 FactoryBean 的区别</title>
      <link>https://zhixiangyuan.github.io/2019/12/22/spring-%E4%B8%AD-beanfactory-%E5%92%8C-factorybean-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 22 Dec 2019 16:32:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/22/spring-%E4%B8%AD-beanfactory-%E5%92%8C-factorybean-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>BeanFactory 是生产 bean 的工厂 FactoryBean 是工厂的 bean</description>
    </item>
    
    <item>
      <title>JDK 与 Spring 中的事件模型</title>
      <link>https://zhixiangyuan.github.io/2019/12/16/jdk-%E4%B8%8E-spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 16 Dec 2019 16:55:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/16/jdk-%E4%B8%8E-spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</guid>
      <description>1 事件模型 JDK 中提供了一个接口和一个类给用户实现自己的事件机制，一个是 EventObject 事件，另一个是 EventListener 事件监听器。 一般使用是都是在事件监听器中实现相应的方法</description>
    </item>
    
    <item>
      <title>spring 中的 Resource 和 ResourceLoader</title>
      <link>https://zhixiangyuan.github.io/2019/12/16/spring-%E4%B8%AD%E7%9A%84-resource-%E5%92%8C-resourceloader/</link>
      <pubDate>Mon, 16 Dec 2019 10:00:29 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/16/spring-%E4%B8%AD%E7%9A%84-resource-%E5%92%8C-resourceloader/</guid>
      <description>1 Resource 由于 Java 定义的 java.net.URL（Uniform Resource Locator）统一资源定位器有些狭隘，无法做到统一定位资源的作用（todo 这里有</description>
    </item>
    
    <item>
      <title>Spring Xml 配置文件格式</title>
      <link>https://zhixiangyuan.github.io/2019/12/13/spring-xml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Fri, 13 Dec 2019 13:23:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/12/13/spring-xml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
    <item>
      <title>如何在 Spring 的 Yml 中使用随机数与字符串</title>
      <link>https://zhixiangyuan.github.io/2019/09/19/%E5%A6%82%E4%BD%95%E5%9C%A8-spring-%E7%9A%84-yml-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 19 Sep 2019 17:31:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/2019/09/19/%E5%A6%82%E4%BD%95%E5%9C%A8-spring-%E7%9A%84-yml-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>占位符 描述 ${random.value} 取得随机字符串 ${random.int} 取得随机 int 型数据 ${random.long} 取得随机 long 型数据 ${random.int(10)} 取得 10 以内的随机数 ${random.int[10,20]} 取得 10~20 的随机数 ${自定义占位符 or 环境变量} 自定义占位符 or</description>
    </item>
    
  </channel>
</rss>