<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on Yuanzx Blog</title>
    <link>https://zhixiangyuan.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on Yuanzx Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>yuanzx</copyright>
    <lastBuildDate>Sun, 13 Oct 2019 17:12:18 +0800</lastBuildDate>
    
	<atom:link href="https://zhixiangyuan.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>解释器模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 13 Oct 2019 17:12:18 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>解释器模式提供了评估语言的语法或表达式的方法，它属于行为型模式，这种模式实现了一个表达式接口，该接口解释一个特定的上下文，这种模式被用在 SQL 解</description>
    </item>
    
    <item>
      <title>中介者模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 13 Oct 2019 17:01:18 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>在现实生活中，有很多中介者模式的身影，比如说 QQ 聊天平台，微信聊天平台。这行平台就像是一个中介，用户通过这些平台来和别的用户交流，如果没有这些</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 12 Oct 2019 14:49:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>状态模式就是将状态抽象成一个接口，这样就可以通过实现不同的状态来对类做不同的操作，而不这样写则会依赖 if else，对于状态很多的情况扩展能力没</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 11 Oct 2019 21:37:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>迭代器模式常见于 Java 的集合类，使用该模式顺序访问集合对象的元素，不需要知道集合对象的底层表示。 1 上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Oct 2019 21:43:24 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>命令模式是为了将调用者和执行进行解藕，所以引入了中间层命令，下面举一个例子，我们实现一个可以播放磁带的磁带机，然后用它来播放磁带。 中介者模式</description>
    </item>
    
    <item>
      <title>备忘录模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Oct 2019 18:33:20 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>备忘录模式指的是一个对象内部有一些状态需要发生改变，希望在改变过后能回到原来的状态，这个时候就需要有个备忘录，以及保存的备忘的内容。整个结构</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 08 Oct 2019 09:25:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>享元模式就是单例模式的扩展，目的同样是避免重复创建对象，不过享元模式并不像单例模式一样，一个类只创建一个单例，享元模式避免重复创建的对象是指</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 07 Oct 2019 21:43:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>当接收到一个请求时，可能存在多种解析方式，但是只有一种解析方式能够满足，这个时候我们可以将这些解析方式组织成责任链的模式，让请求在责任链中传</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 07 Oct 2019 14:43:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂模式提供另外一种创建对象的方式，这种方式屏蔽了创建对象的细节，所以可以实现很多骚操作。下面的代码就是一个简单的工厂，通过传入全类名来创建</description>
    </item>
    
    <item>
      <title>设计模式的分类</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/</link>
      <pubDate>Fri, 04 Oct 2019 17:49:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/</guid>
      <description>设计模式主要分为三类创建型模式、结构型模式和行为型模式。 1 创建型模式 创建型模式主要关注于对象实例化的过程，创建型模式有： 单例模式 原型模式 建造</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 04 Oct 2019 17:14:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/october/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>桥接模式的核心是将事物和其具体实现分开，这句话乍看上去和策略模式很像，但其立意包含策略模式，同时又高于策略模式。其实桥接模式，通过定义规范的</description>
    </item>
    
    <item>
      <title>门面模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 23 Sep 2019 07:46:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid>
      <description>门面模式通过统一的抽象接口访问具体实现，让使用者可以无痛更换具体实现，在目前的日志系统中广泛使用。 1 演示代码 创建统一抽象接口 1 2 3 4 5 6 7 8</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Sep 2019 12:35:03 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>适配器模式还是很好理解的，简单来讲就是我有一个 pencil，我还有一个 apple，然后通过一个适配器，嗯 pencil and apple。我还有一个 carro</description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Sep 2019 11:14:07 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰器模式其实就是静态代理模式，与目标对象实现相同的接口然后对其进行一次包装，上代码。 1 代码实现 代码来自菜鸟教程 创建 Shape 接口 1 2 3 public interface Shape { void draw();</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Sep 2019 09:20:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式中有三个角色，分别是 Subject、Observer and Event，Subject 中会存储订阅了该主题的 Observer，在 Observer 状态发</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 17 Sep 2019 10:16:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式非常的简单，对于 Java 来说，就是一个接口多种实现，使用不同的实现就是更换策略。 1 策略模式案例 先定义好策略接口 1 2 3 public interface Strategy { public int doOperation(int num1, int num2); }</description>
    </item>
    
    <item>
      <title>访问者模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 17 Sep 2019 09:57:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/september/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>访问者模式，通过实现访问者的接口来访问实体当中相应的部分，下面先看代码。 1 搭建架子 我们先搭建一辆车，然后通过访问者模式去访问车的各个部分。 1</description>
    </item>
    
  </channel>
</rss>