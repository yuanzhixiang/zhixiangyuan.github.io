<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构与算法 on Yuanzx Blog</title>
    <link>https://zhixiangyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 数据结构与算法 on Yuanzx Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>yuanzx</copyright>
    <lastBuildDate>Mon, 21 Oct 2019 10:13:37 +0800</lastBuildDate>
    
	<atom:link href="https://zhixiangyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode: 450 删除二叉搜索树中的节点</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 21 Oct 2019 10:13:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>1 题目 二叉搜索树中的搜索 2 解 2.1 我的解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 18 Oct 2019 13:56:39 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>快速排序使用分治思想，实际实现过程和二叉树的前序遍历很像，在第一次碰到节点时进行遍历分区，然后再对子分区进行遍历分区，直到分区中只有一个节点</description>
    </item>
    
    <item>
      <title>Leetcode: 912 排序数组</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 18 Oct 2019 08:35:40 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>1 题目 排序数组 2 解 2.1 我的解 2.1.1 归并排序 时间复杂度: O(nlogn) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 17 Oct 2019 00:36:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>归并排序通过对数组进行二叉树式的拆分最后再合并，完成了其排序过程，并将时间复杂度下降到了 O(nlogn) 的程度，下面是一个数组索引 0 - 9 的数组的拆分的过程</description>
    </item>
    
    <item>
      <title>跳表</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Wed, 16 Oct 2019 10:51:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E8%B7%B3%E8%A1%A8/</guid>
      <description>1 跳表的数据结构 跳表是在链表上做的改善，解决了链表查找时间复杂度为 O(n) 的问题，改善之后的跳表可以像二分查找一样，实现时间复杂度为 O(logn) 的效果。 对于</description>
    </item>
    
    <item>
      <title>堆的应用</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 15 Oct 2019 14:52:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>1 优先级队列 优先级队列，我的理解就是一个有排序顺序的队列，对于一般的队列，都是 FIFO，但是对于优先级队列，队列内部的顺序并不是 FIFO 的，在入队</description>
    </item>
    
    <item>
      <title>堆和堆排序</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 14 Oct 2019 16:36:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>1 堆 堆是一种特殊的树，它需要满足两个要求： 堆是一棵完全二叉树 堆中每一个节点的值必须大于等于（或小于等于）其子树中每个节点的值 根据第二个特性可</description>
    </item>
    
    <item>
      <title>平衡二叉查找树</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</link>
      <pubDate>Sun, 13 Oct 2019 15:24:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</guid>
      <description>二叉树的时间复杂度在理想状况下是 O(logn) 但是在频繁的动态更新下可能就退化成 O(n) 或者接近 O(n) 了，这个问题不解决，二叉树的性能就太差了，由此便引出了平衡二</description>
    </item>
    
    <item>
      <title>二叉树基础</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 11 Oct 2019 09:51:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/</guid>
      <description>1 树的基础知识 节点的高度：节点到叶子结点的边数 节点的深度：跟节点到这个节点经历的边数 节点的层数：节点的深度 + 1 树的高度：根节点的高度 2 二叉树</description>
    </item>
    
    <item>
      <title>Leetcode: 701 二叉搜索树中的插入操作</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 08 Oct 2019 08:05:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</guid>
      <description>1 题目 二叉搜索树中的插入操作 2 解 2.1 我的解 时间复杂度: O(logn) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Definition for</description>
    </item>
    
    <item>
      <title>Leetcode: 700 二叉搜索树中的搜索</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sun, 29 Sep 2019 08:01:03 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</guid>
      <description>1 题目 二叉搜索树中的搜索 2 解 2.1 我的解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution</description>
    </item>
    
    <item>
      <title>Leetcode: 27 移除元素</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 28 Sep 2019 07:57:58 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>1 题目 移除元素 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeElement(int[] nums, int val) { int newIndex = 0; int oldIndex = 0; for (; oldIndex &amp;lt; nums.length; oldIndex++) { if (val != nums[oldIndex]) {</description>
    </item>
    
    <item>
      <title>Leetcode: 26 删除排序数组中的重复项</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Fri, 27 Sep 2019 08:12:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>1 题目 删除排序数组中的重复项 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int removeDuplicates(int[] nums) { int oldIndex = 1; int newIndex = 1; for (; oldIndex &amp;lt; nums.length; oldIndex++)</description>
    </item>
    
    <item>
      <title>Leetcode: 3 无重复字符的最长子串</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 26 Sep 2019 07:56:34 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>1 题目 无重复字符的最长子串 2 解 2.1 我的解 时间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int lengthOfLongestSubstring(String s) { char[] result = s.toCharArray(); HashMap&amp;lt;Object, Integer&amp;gt; map = new HashMap(); int maxLength = 0;</description>
    </item>
    
    <item>
      <title>Leetcode: 173 二叉搜索树迭代器</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Wed, 25 Sep 2019 07:46:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>1 题目 二叉搜索树迭代器 2 解 2.1 我的解 先保存树左边的节点进队列，当队列空了再让后边的节点进队列，这样似乎还是没有满足使用 O(h) 的内存空间 h 是树的高度</description>
    </item>
    
    <item>
      <title>Leetcode: 98 验证二叉搜索树</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Tue, 24 Sep 2019 07:09:35 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>1 题目 验证二叉搜索树 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(n) 本解中的 list 可以换成 stack，只存储上一个节点数，这样就能节省空间。 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>Leetcode: 401 二进制手表</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</link>
      <pubDate>Mon, 23 Sep 2019 07:20:33 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</guid>
      <description>1 题目 二进制手表 2 解 2.1 别人的解 很巧妙的解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List&amp;lt;String&amp;gt; readBinaryWatch(int num) { List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); // 直接遍历 0:00 -&amp;gt; 12:00 每个时</description>
    </item>
    
    <item>
      <title>Leetcode: 151 最小栈</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-151-%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Sun, 22 Sep 2019 07:43:01 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-151-%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>1 题目 最小栈 2 解 2.1 我的解 题意要求的常数时间 getMin，只需要在程序中添加一个最小值成员变量，在每次 push 时判断是不是更小，若更小则将最小值更新</description>
    </item>
    
    <item>
      <title>Leetcode: 141 环形链表</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 09:53:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>1 题目 环形链表 2 解 2.1 我的解 时间复杂度: O(n) 空间负载的: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; *</description>
    </item>
    
    <item>
      <title>Leetcode: 136 只出现一次的数字</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 20 Sep 2019 06:45:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>1 题目 只出现一次的数字 2 解 2.1 我的解 2.1.1 HashSet 解 时间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int singleNumber(int[] nums) { HashSet hashset = new HashSet(); for (int i = 0; i &amp;lt; nums.length; i++) { if (hashset.contains(nums[i])) { hashset.remove(nums[i]); } else {</description>
    </item>
    
    <item>
      <title>Leetcode: 21 合并两个有序链表</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 19 Sep 2019 07:54:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>1 题目 合并两个有序链表 2 解 2.1 我的解 最近什么情况，为什么写出来的解又臭又长，可能是我又想写递归，又写不出简洁的递归的原因吧。 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>Leetcode: 112 路径总和</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</link>
      <pubDate>Wed, 18 Sep 2019 06:55:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</guid>
      <description>1 题目 路径总和 2 解 2.1 我的解 空间复杂度: O(log(n)) 时间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>Leetcode: 7 整数反转</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Tue, 17 Sep 2019 16:46:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>1 题目 整数反转 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int reverse(int num) { try { if (num &amp;gt;= 0) { String strNum = reverseInt(num);</description>
    </item>
    
    <item>
      <title>Leetcode: 101 对称二叉树</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 17 Sep 2019 07:47:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 题目 对称二叉树 2 解 2.1 我的解 思路拿取对称的节点进行比较，相同返回 true，不相同返回 false 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13</description>
    </item>
    
    <item>
      <title>Leetcode: 104 二叉树的最大深度</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Mon, 16 Sep 2019 07:08:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>1 题目 二叉树的最大深度 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for a binary tree node. * public class</description>
    </item>
    
    <item>
      <title>Leetcode: 20 有效的括号</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Sun, 15 Sep 2019 07:13:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>1 题目 有效的括号 2 解 2.1 我的解 时间复杂度 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public boolean isValid(String s) { Stack</description>
    </item>
    
    <item>
      <title>Leetcode: 2 两数相加</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sat, 14 Sep 2019 09:14:06 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>1 题目 两数相加 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43</description>
    </item>
    
    <item>
      <title>Leetcode: 146 LRU 缓存机制</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-146-lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 13 Sep 2019 09:20:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-146-lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>1 题目 LRU 缓存机制 2 解 2.1 我的解 没解出来 2.2 官方解法 厉害了，对 LinkedhashMap 稍加改造就完成了这个效果，强 LRU = Last recent used，最近被使用的缓存不要被覆盖掉。 1 2 3</description>
    </item>
    
    <item>
      <title>Leetcode: 102 二叉树的层序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 08:08:15 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的前序遍历 2 解 2.1 我的解 由于他要对每一层进行分层，所以我想的就是通过 List&amp;lt;List&amp;lt;TreeNode&amp;gt;&amp;gt; 去分层，但是我这个解跑出来的效果看上去时间复杂度和空间复杂度</description>
    </item>
    
    <item>
      <title>Leetcode: 145 二叉树的后序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 07:21:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的后序遍历 2 解 2.1 我的解 时间复杂度 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>Leetcode: 94 二叉树的中序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 07:17:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的中序遍历 2 解 2.1 我的解 时间复杂度 O(n) // 每个节点遍历一次所以是 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a</description>
    </item>
    
    <item>
      <title>Leetcode: 144 二叉树的前序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 07:09:30 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的前序遍历 2 解 2.1 我的解 时间复杂度 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>Leetcode: 121 买卖股票的最佳时机</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Wed, 11 Sep 2019 07:58:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid>
      <description>1 题目 买卖股票的最佳时机 2 解 2.1 一遍遍历 时间复杂度: O(n) 空间复杂度: O(1) 碰到最低价格就将价格保存下来，然后将最低价格和后面的最高价格做比较，保存利</description>
    </item>
    
    <item>
      <title>Leetcode: 70 爬楼梯</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 09:43:30 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>1 题目 爬楼梯 2 解 2.1 我的解 没解出来 2.2 官方题解 2.2.1 暴力法 通过递归的方式模拟爬楼梯，不过这个方法在 leetcode 上面跑会超时 时间复杂度: O(\(2^n\)) 空间复杂度: O(1) 1 2 3 4</description>
    </item>
    
    <item>
      <title>Leetcode: 53 最大子序和</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link>
      <pubDate>Mon, 09 Sep 2019 08:17:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid>
      <description>1 题目 最大子序和 2 解 2.1 我的解 双重循环遍历，把所有可能性都算一遍 时间复杂度: O(\(n^2\)) 空间复杂度: O(1) 执行时间: 95ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</description>
    </item>
    
    <item>
      <title>Leetcode: 1115 交替打印 FooBar</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0-foobar/</link>
      <pubDate>Wed, 14 Aug 2019 20:54:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0-foobar/</guid>
      <description>1 题目 交替打印 FooBar 2 解 2.1 我的解 思路，先打印 Foo，然后通知另一个线程打印 Bar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class</description>
    </item>
    
    <item>
      <title>Leetcode: 1114 按序打印</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</link>
      <pubDate>Tue, 13 Aug 2019 11:05:30 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</guid>
      <description>1 题目 按序打印 2 解 2.1 我的解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Foo { // 题目确保使用单例模式 public Foo() { } private boolean</description>
    </item>
    
    <item>
      <title>冒泡排序、插入排序、选择排序</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 17 Jul 2019 21:59:06 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>1. 冒泡排序 1.1 原理 通过遍历所有元素，判断相邻的两个元素是否满足大小关系，如果不满足则进行交换，重复 n 次，就完成 n 个数据的排序工作。 1.2 代码实现 1</description>
    </item>
    
    <item>
      <title>最好、最坏、平均、均摊时间复杂度</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Thu, 11 Jul 2019 10:17:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>1 最好、最坏时间复杂度 先看下述代码 1 2 3 4 5 6 7 8 9 10 11 int find(int[] array, int x) { int pos = -1; int n = array.length; for (int i = 0; i &amp;lt; n; i++) { if (array[i] == x) { pos = i; break; } } return pos; } 该代码用</description>
    </item>
    
    <item>
      <title>时间复杂度与空间复杂度</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 10 Jul 2019 18:36:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>1 时间复杂度 分析程序时间复杂度的时候只需要关注循环中的代码即可 1.1 常见的时间复杂度 常见的时间复杂度有 O(1), O(n), O(logn), O(nlogn), O(\(n^2\)).. O(\(n^k\)), O(\(2^n\)), O(n!) 其中 O(\(2^n\)) 和 O(n!) 在数据规模增大时</description>
    </item>
    
    <item>
      <title>Leetcode: 1 两数之和</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 02 Jul 2019 20:23:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>1 题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应</description>
    </item>
    
  </channel>
</rss>