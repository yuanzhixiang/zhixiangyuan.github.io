<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yuanzx Blog</title>
    <link>https://zhixiangyuan.github.io/post/</link>
    <description>Recent content in Posts on Yuanzx Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>yuanzx</copyright>
    <lastBuildDate>Mon, 07 Oct 2019 21:43:26 +0800</lastBuildDate>
    
	<atom:link href="https://zhixiangyuan.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>责任链模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 07 Oct 2019 21:43:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>当接收到一个请求时，可能存在多种解析方式，但是只有一种解析方式能够满足，这个时候我们可以将这些解析方式组织成责任链的模式，让请求在责任链中传</description>
    </item>
    
    <item>
      <title>布偶猫的颜色花纹分类</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E5%B8%83%E5%81%B6%E7%8C%AB%E7%9A%84%E9%A2%9C%E8%89%B2%E8%8A%B1%E7%BA%B9%E5%88%86%E7%B1%BB/</link>
      <pubDate>Mon, 07 Oct 2019 17:23:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E5%B8%83%E5%81%B6%E7%8C%AB%E7%9A%84%E9%A2%9C%E8%89%B2%E8%8A%B1%E7%BA%B9%E5%88%86%E7%B1%BB/</guid>
      <description>影响布偶猫的外形主要有三个因素，分别是颜色、色块位置、是否有山猫纹，下面一一举例 1 颜色分类 颜色大的方向分为黑色系、巧克力色系、红色系、玳瑁色</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 07 Oct 2019 14:43:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂模式提供另外一种创建对象的方式，这种方式屏蔽了创建对象的细节，所以可以实现很多骚操作。下面的代码就是一个简单的工厂，通过传入全类名来创建</description>
    </item>
    
    <item>
      <title>路西法效应</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E8%B7%AF%E8%A5%BF%E6%B3%95%E6%95%88%E5%BA%94/</link>
      <pubDate>Sun, 06 Oct 2019 12:51:54 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E8%B7%AF%E8%A5%BF%E6%B3%95%E6%95%88%E5%BA%94/</guid>
      <description>1 环境使人走向邪恶的七步 无意中迈出的第一步 对他人去人性化 对自己去个体化 推卸个人责任 盲目服从权威 不加批判的遵从群体规范 对恶行为袖手旁观，消极容</description>
    </item>
    
    <item>
      <title>谈论行业的文章汇总</title>
      <link>https://zhixiangyuan.github.io/post/hovel/%E8%B0%88%E8%AE%BA%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sat, 05 Oct 2019 21:46:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/%E8%B0%88%E8%AE%BA%E8%A1%8C%E4%B8%9A%E7%9A%84%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</guid>
      <description>1 浅谈程序员的行业选择 &amp;mdash; 程序人生 该文章中将行业分为了互联网、甲方、乙方和游戏，同时，互联网又被分成传统互联网和移动互联网。对于互联网企业，文</description>
    </item>
    
    <item>
      <title>Class 方法之 forName(String className) 小记</title>
      <link>https://zhixiangyuan.github.io/post/hovel/class-%E6%96%B9%E6%B3%95%E4%B9%8B-fornamestring-classname-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Fri, 04 Oct 2019 20:29:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/class-%E6%96%B9%E6%B3%95%E4%B9%8B-fornamestring-classname-%E5%B0%8F%E8%AE%B0/</guid>
      <description>Class.forName(String className) 这个方法的作用就是触发类的初始化动作 1 2 public static Class&amp;lt;?&amp;gt; forName(String className) throws ClassNotFoundException 这个方法目前就仅在 JDBC 的初始化的时候见过，他的目的就是触发 JDBC 驱动注册到代码中，代码如</description>
    </item>
    
    <item>
      <title>设计模式的分类</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/</link>
      <pubDate>Fri, 04 Oct 2019 17:49:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/</guid>
      <description>设计模式主要分为三类创建型模式、结构型模式和行为型模式。 1 创建型模式 创建型模式主要关注于对象实例化的过程，创建型模式有： 单例模式 原型模式 建造</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 04 Oct 2019 17:14:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>桥接模式的核心是将事物和其具体实现分开，这句话乍看上去和策略模式很像，但其立意包含策略模式，同时又高于策略模式。其实桥接模式，通过定义规范的</description>
    </item>
    
    <item>
      <title>Leetcode: 700 二叉搜索树中的搜索</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sun, 29 Sep 2019 08:01:03 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</guid>
      <description>1 题目 二叉搜索树中的搜索 2 解 2.1 我的解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution</description>
    </item>
    
    <item>
      <title>Leetcode: 27 移除元素</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 28 Sep 2019 07:57:58 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>1 题目 移除元素 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeElement(int[] nums, int val) { int newIndex = 0; int oldIndex = 0; for (; oldIndex &amp;lt; nums.length; oldIndex++) { if (val != nums[oldIndex]) {</description>
    </item>
    
    <item>
      <title>Leetcode: 26 删除排序数组中的重复项</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Fri, 27 Sep 2019 08:12:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>1 题目 删除排序数组中的重复项 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int removeDuplicates(int[] nums) { int oldIndex = 1; int newIndex = 1; for (; oldIndex &amp;lt; nums.length; oldIndex++)</description>
    </item>
    
    <item>
      <title>Leetcode: 3 无重复字符的最长子串</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 26 Sep 2019 07:56:34 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>1 题目 无重复字符的最长子串 2 解 2.1 我的解 时间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int lengthOfLongestSubstring(String s) { char[] result = s.toCharArray(); HashMap&amp;lt;Object, Integer&amp;gt; map = new HashMap(); int maxLength = 0;</description>
    </item>
    
    <item>
      <title>Vim 命令小记</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/vim-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Wed, 25 Sep 2019 09:54:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/vim-%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 移动命令 1.1 行间搜索移动 f${char} 移动到 char 字符的第一个字母上 t${char} 移动到 char 字符的第一个字母前面 &amp;rsquo;;&amp;rsquo; 配合 f 和 t 搜索该行的下一个 &amp;rsquo;,&amp;rsquo; 配合 f 和 t 搜索该行的上一个 1.2</description>
    </item>
    
    <item>
      <title>Leetcode: 173 二叉搜索树迭代器</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Wed, 25 Sep 2019 07:46:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>1 题目 二叉搜索树迭代器 2 解 2.1 我的解 先保存树左边的节点进队列，当队列空了再让后边的节点进队列，这样似乎还是没有满足使用 O(h) 的内存空间 h 是树的高度</description>
    </item>
    
    <item>
      <title>Leetcode: 98 验证二叉搜索树</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Tue, 24 Sep 2019 07:09:35 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>1 题目 验证二叉搜索树 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(n) 本解中的 list 可以换成 stack，只存储上一个节点数，这样就能节省空间。 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>Monitorenter 与 Monitorexit 小记</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/monitorenter-%E4%B8%8E-monitorexit-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 23 Sep 2019 10:07:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/monitorenter-%E4%B8%8E-monitorexit-%E5%B0%8F%E8%AE%B0/</guid>
      <description>首先对如下代码进行编译 1 2 3 4 5 public void Test() { synchronized(this) { System.out.println(); } } 将得到的字节码通过 javap 反编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void</description>
    </item>
    
    <item>
      <title>门面模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 23 Sep 2019 07:46:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</guid>
      <description>门面模式通过统一的抽象接口访问具体实现，让使用者可以无痛更换具体实现，在目前的日志系统中广泛使用。 1 演示代码 创建统一抽象接口 1 2 3 4 5 6 7 8</description>
    </item>
    
    <item>
      <title>Leetcode: 401 二进制手表</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</link>
      <pubDate>Mon, 23 Sep 2019 07:20:33 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</guid>
      <description>1 题目 二进制手表 2 解 2.1 别人的解 很巧妙的解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List&amp;lt;String&amp;gt; readBinaryWatch(int num) { List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); // 直接遍历 0:00 -&amp;gt; 12:00 每个时</description>
    </item>
    
    <item>
      <title>Ant 风格路径表达式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/ant-%E9%A3%8E%E6%A0%BC%E8%B7%AF%E5%BE%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 22 Sep 2019 10:57:53 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/ant-%E9%A3%8E%E6%A0%BC%E8%B7%AF%E5%BE%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>Ant 风格路径表达式就是一个精简版的正则表达式 通配符 说明 ? 匹配任何单字符 * 匹配 0 或者任意数量的字符 ** 匹配 0 或者更多的目录</description>
    </item>
    
    <item>
      <title>Leetcode: 151 最小栈</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-151-%E6%9C%80%E5%B0%8F%E6%A0%88/</link>
      <pubDate>Sun, 22 Sep 2019 07:43:01 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-151-%E6%9C%80%E5%B0%8F%E6%A0%88/</guid>
      <description>1 题目 最小栈 2 解 2.1 我的解 题意要求的常数时间 getMin，只需要在程序中添加一个最小值成员变量，在每次 push 时判断是不是更小，若更小则将最小值更新</description>
    </item>
    
    <item>
      <title>Leetcode: 141 环形链表</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 21 Sep 2019 09:53:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>1 题目 环形链表 2 解 2.1 我的解 时间复杂度: O(n) 空间负载的: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; *</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Sep 2019 12:35:03 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>适配器模式还是很好理解的，简单来讲就是我有一个 pencil，我还有一个 apple，然后通过一个适配器，嗯 pencil and apple。我还有一个 carro</description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Sep 2019 11:14:07 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰器模式其实就是静态代理模式，与目标对象实现相同的接口然后对其进行一次包装，上代码。 1 代码实现 代码来自菜鸟教程 创建 Shape 接口 1 2 3 public interface Shape { void draw();</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Sep 2019 09:20:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式中有三个角色，分别是 Subject、Observer and Event，Subject 中会存储订阅了该主题的 Observer，在 Observer 状态发</description>
    </item>
    
    <item>
      <title>Leetcode: 136 只出现一次的数字</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 20 Sep 2019 06:45:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>1 题目 只出现一次的数字 2 解 2.1 我的解 2.1.1 HashSet 解 时间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int singleNumber(int[] nums) { HashSet hashset = new HashSet(); for (int i = 0; i &amp;lt; nums.length; i++) { if (hashset.contains(nums[i])) { hashset.remove(nums[i]); } else {</description>
    </item>
    
    <item>
      <title>如何在 Spring 的 Yml 中使用随机数与字符串</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E5%9C%A8-spring-%E7%9A%84-yml-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 19 Sep 2019 17:31:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E5%9C%A8-spring-%E7%9A%84-yml-%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>占位符 描述 ${random.value} 取得随机字符串 ${random.int} 取得随机 int 型数据 ${random.long} 取得随机 long 型数据 ${random.int(10)} 取得 10 以内的随机数 ${random.int[10,20]} 取得 10~20 的随机数 ${自定义占位符 or 环境变量} 自定义占位符 or</description>
    </item>
    
    <item>
      <title>如何在 Leetcode 上调试代码</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E5%9C%A8-leetcode-%E4%B8%8A%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 19 Sep 2019 09:39:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E5%9C%A8-leetcode-%E4%B8%8A%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/</guid>
      <description>最近经常在 leetcode 上面刷题，不过发现在上面写的代码如果遇到一些 bug 只能肉眼 debug，如果 不能肉眼 debug 出来就比较难受了，还要打开 ide 真实模拟一下。不过今</description>
    </item>
    
    <item>
      <title>Leetcode: 21 合并两个有序链表</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 19 Sep 2019 07:54:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>1 题目 合并两个有序链表 2 解 2.1 我的解 最近什么情况，为什么写出来的解又臭又长，可能是我又想写递归，又写不出简洁的递归的原因吧。 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>ArrayList 使用注意事项</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/arraylist-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Wed, 18 Sep 2019 18:24:57 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/arraylist-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>1 ArrayList 使用注意事项 如果一边对 ArrayList 中的元素做修改，一边使用 Iterator 对 ArrayList 进行遍历，则会抛出 ConcurrentModificationException 异常。 2 为什么会出现 ConcurrentModificationException 这个异常 通过翻看源码，能够找到下面这段代</description>
    </item>
    
    <item>
      <title>如何介绍一个集合类</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</link>
      <pubDate>Wed, 18 Sep 2019 16:02:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</guid>
      <description>很多时候，作为一个程序员，仅仅会使用集合类是不够的，我们经常需要向别人介绍集合类，那么，在向别人介绍集合类的时候，我们应该从哪几个角度进行介</description>
    </item>
    
    <item>
      <title>Leetcode: 112 路径总和</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</link>
      <pubDate>Wed, 18 Sep 2019 06:55:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</guid>
      <description>1 题目 路径总和 2 解 2.1 我的解 空间复杂度: O(log(n)) 时间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>临床中的急性肾功能损伤 Akl 可以通过什么指标预警</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E4%B8%B4%E5%BA%8A%E4%B8%AD%E7%9A%84%E6%80%A5%E6%80%A7%E8%82%BE%E5%8A%9F%E8%83%BD%E6%8D%9F%E4%BC%A4-akl-%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%8C%87%E6%A0%87%E9%A2%84%E8%AD%A6/</link>
      <pubDate>Tue, 17 Sep 2019 20:25:18 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E4%B8%B4%E5%BA%8A%E4%B8%AD%E7%9A%84%E6%80%A5%E6%80%A7%E8%82%BE%E5%8A%9F%E8%83%BD%E6%8D%9F%E4%BC%A4-akl-%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%8C%87%E6%A0%87%E9%A2%84%E8%AD%A6/</guid>
      <description>如果在临床中出现急性肾功能损伤即 Akl（下文均以 Akl 作为替代），那么会导致尿量减少甚至无尿，而由于体液的增加，会导致血钾和电解质紊乱，心电 T 波</description>
    </item>
    
    <item>
      <title>Object 中 hashcode() 与 equals() 的关系</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/object-%E4%B8%AD-hashcode-%E4%B8%8E-equals-%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Tue, 17 Sep 2019 17:14:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/object-%E4%B8%AD-hashcode-%E4%B8%8E-equals-%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>情况分为以下四种： hashcode 相等，equals 可能相等 hashcode 不相等，equals 一定不相等 equals 相等，hashcode 一定相等 equals 相等说明是同一个对象，所以 hashcode</description>
    </item>
    
    <item>
      <title>Leetcode: 7 整数反转</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Tue, 17 Sep 2019 16:46:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>1 题目 整数反转 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int reverse(int num) { try { if (num &amp;gt;= 0) { String strNum = reverseInt(num);</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 17 Sep 2019 10:16:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式非常的简单，对于 Java 来说，就是一个接口多种实现，使用不同的实现就是更换策略。 1 策略模式案例 先定义好策略接口 1 2 3 public interface Strategy { public int doOperation(int num1, int num2); }</description>
    </item>
    
    <item>
      <title>访问者模式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 17 Sep 2019 09:57:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>访问者模式，通过实现访问者的接口来访问实体当中相应的部分，下面先看代码。 1 搭建架子 我们先搭建一辆车，然后通过访问者模式去访问车的各个部分。 1</description>
    </item>
    
    <item>
      <title>Leetcode: 101 对称二叉树</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 17 Sep 2019 07:47:27 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>1 题目 对称二叉树 2 解 2.1 我的解 思路拿取对称的节点进行比较，相同返回 true，不相同返回 false 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13</description>
    </item>
    
    <item>
      <title>Java Byte &amp; 0xFF 的作用</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-byte-0xff-%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Mon, 16 Sep 2019 14:40:00 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-byte-0xff-%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>Java 代码中，经常能够见到 byte &amp;amp; 0xFF 这串代码，这是由于 Java 在处理 byte 的时候，将 byte 当作有符号来处理，所以比如说我们要进行 byte &amp;lt;&amp;lt; 8，如果 byte 的第一位为 0，那么在</description>
    </item>
    
    <item>
      <title>Leetcode: 104 二叉树的最大深度</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Mon, 16 Sep 2019 07:08:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>1 题目 二叉树的最大深度 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for a binary tree node. * public class</description>
    </item>
    
    <item>
      <title>Leetcode: 20 有效的括号</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Sun, 15 Sep 2019 07:13:48 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>1 题目 有效的括号 2 解 2.1 我的解 时间复杂度 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public boolean isValid(String s) { Stack</description>
    </item>
    
    <item>
      <title>Leetcode: 2 两数相加</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sat, 14 Sep 2019 09:14:06 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>1 题目 两数相加 2 解 2.1 我的解 时间复杂度: O(n) 空间复杂度: O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43</description>
    </item>
    
    <item>
      <title>Leetcode: 146 LRU 缓存机制</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-146-lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 13 Sep 2019 09:20:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-146-lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>1 题目 LRU 缓存机制 2 解 2.1 我的解 没解出来 2.2 官方解法 厉害了，对 LinkedhashMap 稍加改造就完成了这个效果，强 LRU = Last recent used，最近被使用的缓存不要被覆盖掉。 1 2 3</description>
    </item>
    
    <item>
      <title>Leetcode: 102 二叉树的层序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 08:08:15 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的前序遍历 2 解 2.1 我的解 由于他要对每一层进行分层，所以我想的就是通过 List&amp;lt;List&amp;lt;TreeNode&amp;gt;&amp;gt; 去分层，但是我这个解跑出来的效果看上去时间复杂度和空间复杂度</description>
    </item>
    
    <item>
      <title>Leetcode: 145 二叉树的后序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 07:21:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的后序遍历 2 解 2.1 我的解 时间复杂度 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>Leetcode: 94 二叉树的中序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 07:17:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的中序遍历 2 解 2.1 我的解 时间复杂度 O(n) // 每个节点遍历一次所以是 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a</description>
    </item>
    
    <item>
      <title>Leetcode: 144 二叉树的前序遍历</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 12 Sep 2019 07:09:30 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>1 题目 二叉树的前序遍历 2 解 2.1 我的解 时间复杂度 O(n) 空间复杂度 O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode</description>
    </item>
    
    <item>
      <title>Leetcode: 121 买卖股票的最佳时机</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Wed, 11 Sep 2019 07:58:02 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</guid>
      <description>1 题目 买卖股票的最佳时机 2 解 2.1 一遍遍历 时间复杂度: O(n) 空间复杂度: O(1) 碰到最低价格就将价格保存下来，然后将最低价格和后面的最高价格做比较，保存利</description>
    </item>
    
    <item>
      <title>Leetcode: 70 爬楼梯</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Tue, 10 Sep 2019 09:43:30 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>1 题目 爬楼梯 2 解 2.1 我的解 没解出来 2.2 官方题解 2.2.1 暴力法 通过递归的方式模拟爬楼梯，不过这个方法在 leetcode 上面跑会超时 时间复杂度: O(\(2^n\)) 空间复杂度: O(1) 1 2 3 4</description>
    </item>
    
    <item>
      <title>Mybatis Plugin 使用案例</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/mybatis-plugin-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Tue, 10 Sep 2019 07:34:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/mybatis-plugin-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>Mybatis 插件，实现功能的插件又可称之为拦截器，主要提供对 org.apache.ibatis.executor.Executor、org.apach</description>
    </item>
    
    <item>
      <title>Mybatis ObjectFactory 使用案例</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/mybatis-objectfactory-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Tue, 10 Sep 2019 07:02:15 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/mybatis-objectfactory-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>Mybatis 每次创建结果对象的新实例时，它都会使用一个对象工厂来完成。默认的对象工厂仅仅是实例化目标类，要么通过默认构造方法，要么在构造方法上参数映射</description>
    </item>
    
    <item>
      <title>Leetcode: 53 最大子序和</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link>
      <pubDate>Mon, 09 Sep 2019 08:17:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid>
      <description>1 题目 最大子序和 2 解 2.1 我的解 双重循环遍历，把所有可能性都算一遍 时间复杂度: O(\(n^2\)) 空间复杂度: O(1) 执行时间: 95ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19</description>
    </item>
    
    <item>
      <title>Mybatis TypeHandler 使用案例</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/mybatis-typehandler-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 09 Sep 2019 07:20:41 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/mybatis-typehandler-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/</guid>
      <description>数据库的数据类型与 Java 中的数据类型存在差异，当需要对两者做特定的转换时，Mybatis 提供了 TypeHandler 来实现转换操作，以下是一个实际案例，通过将 Java 中的</description>
    </item>
    
    <item>
      <title>Leetcode: 1115 交替打印 FooBar</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0-foobar/</link>
      <pubDate>Wed, 14 Aug 2019 20:54:44 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-1115-%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0-foobar/</guid>
      <description>1 题目 交替打印 FooBar 2 解 2.1 我的解 思路，先打印 Foo，然后通知另一个线程打印 Bar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class</description>
    </item>
    
    <item>
      <title>Leetcode: 1114 按序打印</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</link>
      <pubDate>Tue, 13 Aug 2019 11:05:30 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</guid>
      <description>1 题目 按序打印 2 解 2.1 我的解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Foo { // 题目确保使用单例模式 public Foo() { } private boolean</description>
    </item>
    
    <item>
      <title>Equals 方法的重写规则</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/equals-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99/</link>
      <pubDate>Fri, 09 Aug 2019 09:24:19 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/equals-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99/</guid>
      <description>equals 方法有一些固定的规则，一些类（例如集合类）会按照规则使用 equals 方法，如果重写的时候不按照这些规则进行重写，那么在使用的时候就可能出现莫名其妙的</description>
    </item>
    
    <item>
      <title>ThreadPoolExecutor 解析</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/threadpoolexecutor-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 06 Aug 2019 17:26:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/threadpoolexecutor-%E8%A7%A3%E6%9E%90/</guid>
      <description>1 ThreadPoolExecutor 的构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public ThreadPoolExecutor( // 核心线程数，默认不会被回收掉，但是如果设置了 allowCoreThreadTimeOut //</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA 中的五种断点</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/intellij-idea-%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%AD%E7%82%B9/</link>
      <pubDate>Mon, 05 Aug 2019 16:18:58 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/intellij-idea-%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%AD%E7%82%B9/</guid>
      <description>IntelliJ IDEA 中存在四种断点，分别是行断点、条件断点、方法断点、异常断点、字段观察断点，下面来一一介绍。 1 行断点 行断点，顾名思义，当代码走到断点行的时</description>
    </item>
    
    <item>
      <title>数组的协变与范型的协变</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%8F%E5%8F%98%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98/</link>
      <pubDate>Thu, 01 Aug 2019 16:02:28 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E6%95%B0%E7%BB%84%E7%9A%84%E5%8D%8F%E5%8F%98%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%8F%98/</guid>
      <description>Java 中的数组是支持协变的，而范型不支持协变，先通过下面的代码了解什么是协变。 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { // Number 数组可以指向 Integer 数组 // 这就</description>
    </item>
    
    <item>
      <title>父类如何返回子类</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%88%B6%E7%B1%BB%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E5%AD%90%E7%B1%BB/</link>
      <pubDate>Thu, 01 Aug 2019 14:59:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%88%B6%E7%B1%BB%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E5%AD%90%E7%B1%BB/</guid>
      <description>以 netty 的 AbstractBootstrap 为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 1. 父类中定义一个继承自己的范型 B. B extends AbstractBootstrap&amp;lt;B&amp;gt; public abstract class AbstractBootstrap&amp;lt;B extends AbstractBootstrap&amp;lt;B&amp;gt;&amp;gt;{ ... public B method1() { return self(); } public B method2() { return</description>
    </item>
    
    <item>
      <title>由无效缓存引起的内存泄漏</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%94%B1%E6%97%A0%E6%95%88%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</link>
      <pubDate>Tue, 30 Jul 2019 20:36:52 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%94%B1%E6%97%A0%E6%95%88%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</guid>
      <description>在下面这段代码中存在一个内存泄漏的问题，在使用中表现为性能下降，在极端情况下甚至可能出现 OutOfMemoryError。先看代码，看你是否</description>
    </item>
    
    <item>
      <title>ReentrantLock 详解</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/reentrantlock-%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 24 Jul 2019 21:31:26 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/reentrantlock-%E8%AF%A6%E8%A7%A3/</guid>
      <description>本文基于 JDK 1.8 1 ReentrantLock 的作用 Java 中已经有了 synchronized 的来进行隐式的加锁和解锁，那还为什么还要引入 ReentrantLock 这把锁呢。这主要是 synchronized 的加锁和解锁操作并不灵活，Reentr</description>
    </item>
    
    <item>
      <title>Unsafe 解析</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/unsafe-%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 23 Jul 2019 20:29:17 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/unsafe-%E8%A7%A3%E6%9E%90/</guid>
      <description>本文基于 jdk1.8 Unsafe 位于 sun.misc 包下，提供能直接访问系统内存资源的方法，使得用户能够自主管理内存，使用得当能够提升程序的运行效率。 1 如何获取 Unsafe 实例 下面代码</description>
    </item>
    
    <item>
      <title>Java 线程的生命周期</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sun, 21 Jul 2019 20:09:56 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>Java 语言中的线程本质上就是操作系统的线程，Java 创建线程同样是调用操作系统的 API 来创建线程。所以，了解 Java 线程的生命周期的第一步是了解操作系统线</description>
    </item>
    
    <item>
      <title>冒泡排序、插入排序、选择排序</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 17 Jul 2019 21:59:06 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>1. 冒泡排序 1.1 原理 通过遍历所有元素，判断相邻的两个元素是否满足大小关系，如果不满足则进行交换，重复 n 次，就完成 n 个数据的排序工作。 1.2 代码实现 1</description>
    </item>
    
    <item>
      <title>关于学习</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 17 Jul 2019 20:55:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0/</guid>
      <description>学一个东西，一般从三个角度思考，what、how、why 1 比如说计算机协议 从 what 的角度，所学的是一个什么样的协议，这种协议有怎样的特性，能够解</description>
    </item>
    
    <item>
      <title>如何解决银行转账时的并发问题</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E6%97%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 17 Jul 2019 09:26:08 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E6%97%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</guid>
      <description>1 如何解决银行转账时的并发问题 当出现 A 将钱转给 B 的时候，什么样的方案可以避免在转账时没有并发问题。先看以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description>
    </item>
    
    <item>
      <title>Java 解决可见性和有序性问题的方法</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 16 Jul 2019 17:24:13 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>1 Happens-Before 规则 Java 通过提出 Happens-Before 规则来解决可见性和有序性的问题，Happens-Before 的意思是前面一个操作的结果对后续操作是可见的。 1.1 程序的顺序性</description>
    </item>
    
    <item>
      <title>信息的获取方式</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 16 Jul 2019 15:38:16 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/</guid>
      <description>信息的获取方式主要分为四种 1 搜索引擎 基本上，碰到的问题都可以先上搜索引擎找一找，如果找不到，再考虑别的渠道，如果能找到就不要再去问别人，浪费</description>
    </item>
    
    <item>
      <title>并发编程需要解决的问题</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 16 Jul 2019 10:08:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1 并发编程需要解决的问题 由于 CPU 从单核变成了多核引发了并发问题，其问题有三。一，每个 CPU 都有自己的缓存，当多个线程运行在不同核的 CPU 上并且修改同一</description>
    </item>
    
    <item>
      <title>TCP：连接的建立与断开</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/</link>
      <pubDate>Fri, 12 Jul 2019 21:22:03 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/</guid>
      <description>1 TCP 连接的建立 注：下述序号用 seq 表示 A 生成一个 TCP 数据包，包中 SYN = 1，seq = x，然后将包发给 B 此报文不能携带数据 B 收到包之后，生成一个 SYN = 1，</description>
    </item>
    
    <item>
      <title>TCP：首部结构</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/tcp%E9%A6%96%E9%83%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 12 Jul 2019 15:05:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/tcp%E9%A6%96%E9%83%A8%E7%BB%93%E6%9E%84/</guid>
      <description>1 TCP 数据在 IP 数据报中的封装 2 TCP 首部的数据格式 TCP 首部的数据结构，如果不计选项字段，首部是 20 个字节。 2.1 序号 32 位 序号是 32 位无符号数，序号范围从 0 到</description>
    </item>
    
    <item>
      <title>最好、最坏、平均、均摊时间复杂度</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Thu, 11 Jul 2019 10:17:37 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>1 最好、最坏时间复杂度 先看下述代码 1 2 3 4 5 6 7 8 9 10 11 int find(int[] array, int x) { int pos = -1; int n = array.length; for (int i = 0; i &amp;lt; n; i++) { if (array[i] == x) { pos = i; break; } } return pos; } 该代码用</description>
    </item>
    
    <item>
      <title>时间复杂度与空间复杂度</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 10 Jul 2019 18:36:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>1 时间复杂度 分析程序时间复杂度的时候只需要关注循环中的代码即可 1.1 常见的时间复杂度 常见的时间复杂度有 O(1), O(n), O(logn), O(nlogn), O(\(n^2\)).. O(\(n^k\)), O(\(2^n\)), O(n!) 其中 O(\(2^n\)) 和 O(n!) 在数据规模增大时</description>
    </item>
    
    <item>
      <title>double 转 BigDecimal 造成的精度丢失</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/double-%E8%BD%AC-bigdecimal-%E9%80%A0%E6%88%90%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</link>
      <pubDate>Wed, 10 Jul 2019 16:07:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/double-%E8%BD%AC-bigdecimal-%E9%80%A0%E6%88%90%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/</guid>
      <description>1 2 3 4 5 6 public static void main(String[] args) { double d1 = 36.8d; double d2 = 36.5d; BigDecimal subtract = new BigDecimal(d1).subtract(new BigDecimal(d2)); System.out.println(subtract); } 对于上述类型的计算会得到结果 0.29999999999999715782905695</description>
    </item>
    
    <item>
      <title>网际协议：IP</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEip/</link>
      <pubDate>Tue, 09 Jul 2019 21:06:22 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEip/</guid>
      <description>1 网际协议 IP 简介 IP 协议提供不可靠的、无连接的数据包传输 不可靠指的是从客户端发到目标端的数据包对方可能会收不到 无连接指的是发送的每个数据包都是</description>
    </item>
    
    <item>
      <title>用户数据报协议：UDP</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp/</link>
      <pubDate>Tue, 09 Jul 2019 16:12:09 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp/</guid>
      <description>1 UDP 协议简介 UDP 是一种面向数据包协议，应用层向下传递的每一次操作都会产生一个 UDP 数据包，这一个 UDP 数据包会组装成一份 IP 数据包，这里是一一对应的关系</description>
    </item>
    
    <item>
      <title>学习路径</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Tue, 09 Jul 2019 09:26:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</guid>
      <description>1 学习路径 今天，了解到一个很有意思的词，学习路径。 学习路径在我的理解当中，便是沿着若干个学习目标，通过不断达成学习目标最终完成学习的过程。 光</description>
    </item>
    
    <item>
      <title>Java Gzip 的简单封装</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-gzip-%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/</link>
      <pubDate>Thu, 04 Jul 2019 14:50:20 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-gzip-%E7%9A%84%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/</guid>
      <description>本文基于 Jdk 1.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.util.zip.GZIPInputStream; import java.util.zip.GZIPOutputStream; public class GzipUtil { /** *</description>
    </item>
    
    <item>
      <title>Leetcode: 1 两数之和</title>
      <link>https://zhixiangyuan.github.io/post/algorithms/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Tue, 02 Jul 2019 20:23:42 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/algorithms/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>1 题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应</description>
    </item>
    
    <item>
      <title>Java 性能优化</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</link>
      <pubDate>Tue, 02 Jul 2019 16:22:25 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/java-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</guid>
      <description>1 明确是否需要优化以及要优化到什么程度 首先需要在实践中检测代码是否需要优化，如果不需要优化，那么优化可能占用大量时间，而且优化完了也不会有任</description>
    </item>
    
    <item>
      <title>一次内存泄漏排查的经历</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E7%9A%84%E7%BB%8F%E5%8E%86/</link>
      <pubDate>Mon, 01 Jul 2019 13:14:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E7%9A%84%E7%BB%8F%E5%8E%86/</guid>
      <description>开发环境: JDK: 1.8 Netty: 4.1.21.Final 1 起因 由于我之前写过一个接收医疗设备数据的项目，于是为了压力测试，就又按照该协议实现了一个发送设备数据的项目。这个项目在使</description>
    </item>
    
    <item>
      <title>数据库事务小记</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sat, 24 Nov 2018 14:30:14 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 为什么会有数据库事务 数据库在没有事务的情况下进行读写，可能出现脏读、不可重复读与幻读三种异常，而为了解决这三种异常，便引出了数据库事务，首</description>
    </item>
    
    <item>
      <title>Javap 命令的使用</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2018-hovel/javap-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 05 Nov 2018 10:43:36 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2018-hovel/javap-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>通过 javap 命令可以反编译 .class 文件，实际使用的时候 javap 后面的类名加与不加 .class 都可以。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -help --help -? 打印使用信息（也就是打印图中所示</description>
    </item>
    
    <item>
      <title>final、finally、finalize 的异同</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2018-hovel/finalfinallyfinalize-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Wed, 17 Oct 2018 16:40:23 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2018-hovel/finalfinallyfinalize-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>1 final final 可以用来修饰类、方法、变量 1.1 final 修饰类 final 修饰 class 代表类不可以被继承 1.2 final 修饰变量 final 修饰的变量在初始化之后不能被再次赋值 1.3 final 修饰方法 final 修饰方法</description>
    </item>
    
    <item>
      <title>Exception 与 Error 的异同</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2018-hovel/exception-%E4%B8%8E-error-%E7%9A%84%E5%BC%82%E5%90%8C/</link>
      <pubDate>Tue, 16 Oct 2018 11:26:50 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2018-hovel/exception-%E4%B8%8E-error-%E7%9A%84%E5%BC%82%E5%90%8C/</guid>
      <description>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有继承了 Throwable 的类才可以被 throw 或者 catch，它是异常处理机制的基本组成类型。Exception 是程序正常运行中，可</description>
    </item>
    
    <item>
      <title>sed 小记</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2018-hovel/sed-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Thu, 04 Oct 2018 16:21:59 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2018-hovel/sed-%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 sed 的工作流程 sed 逐行处理文件或输入，默认不会修改文件，除非使用 shell 重定向保存结果。 工作流程： 将正在处理的行保存在一个临时缓存区中（也称为模式空</description>
    </item>
    
    <item>
      <title>grep 小记</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2018-hovel/grep-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Tue, 25 Sep 2018 15:02:04 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2018-hovel/grep-%E5%B0%8F%E8%AE%B0/</guid>
      <description>grep -A [line num]，向下显示多少行，after-context 缩写 -B [line num]，向上显示多少行，before-context 缩写 -C [line num]，上</description>
    </item>
    
    <item>
      <title>tar &amp; scp 小记</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2018-hovel/tar-scp-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 24 Sep 2018 17:35:38 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2018-hovel/tar-scp-%E5%B0%8F%E8%AE%B0/</guid>
      <description>1 scp 命令 上传：scp [文件路径] [用户名]@[IP 地址]:[服务器路径] 下载：scp [用户名]@[IP 地址]:[文件路径] [本地路径] 2 tar 命</description>
    </item>
    
    <item>
      <title>HashMap 不得不说的故事</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/hashmap-%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/</link>
      <pubDate>Mon, 03 Sep 2018 10:13:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/hashmap-%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/</guid>
      <description>本文基于 Jdk 1.8 1 什么是 HashMap 要理解这个问题，首先需要理解什么是 Hash 以及什么是 Map 1.1 什么是 Hash Hash 是一种散列算法，用于确定关键字到指定位置的对应关系 1.2 什么是</description>
    </item>
    
    <item>
      <title>int 入栈指令 iconst、bipush、sipush、ldc</title>
      <link>https://zhixiangyuan.github.io/post/hovel/2019-hovel/int-%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4-iconstbipushsipushldc/</link>
      <pubDate>Sat, 11 Aug 2018 18:47:43 +0800</pubDate>
      
      <guid>https://zhixiangyuan.github.io/post/hovel/2019-hovel/int-%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4-iconstbipushsipushldc/</guid>
      <description>1 前言 本文介绍 int 数值入栈指令 iconst、bipush、sipubh、Idc。 根据 int 取值不同分为以下几种可能性： iconst: [-1, 5] bipush: [-128, -2]∪[6, 127] sipush:</description>
    </item>
    
  </channel>
</rss>